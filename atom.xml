<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YTTE</title>
  
  <subtitle>Personal Blogs</subtitle>
  <link href="https://example.com/atom.xml" rel="self"/>
  
  <link href="https://example.com/"/>
  <updated>2022-03-19T08:51:34.035Z</updated>
  <id>https://example.com/</id>
  
  <author>
    <name>JX</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>456</title>
    <link href="https://example.com/2022/03/19/456/"/>
    <id>https://example.com/2022/03/19/456/</id>
    <published>2022-03-19T08:51:26.000Z</published>
    <updated>2022-03-19T08:51:34.035Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><span id="more"></span><p>fdasfd </p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>https</title>
    <link href="https://example.com/2022/03/19/https/"/>
    <id>https://example.com/2022/03/19/https/</id>
    <published>2022-03-19T06:08:00.000Z</published>
    <updated>2022-03-19T06:12:11.172Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><span id="more"></span><h1 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h1><blockquote><p>视频&#x3D;&#x3D;&#x3D;&#x3D;》<a href="https://www.bilibili.com/video/BV1JS4y1j72U?p=2&spm_id_from=pageDriver">哔哩哔哩_bilibili</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;</summary>
    
    
    
    <category term="服务器" scheme="https://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="Https" scheme="https://example.com/tags/Https/"/>
    
  </entry>
  
  <entry>
    <title>Thread</title>
    <link href="https://example.com/2022/03/19/Thread%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://example.com/2022/03/19/Thread%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-03-19T05:20:02.952Z</published>
    <updated>2022-03-19T07:00:21.984Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="线程的实现方式及其优缺点"><a href="#线程的实现方式及其优缺点" class="headerlink" title="线程的实现方式及其优缺点"></a>线程的实现方式及其优缺点</h1><h2 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCode1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">20</span>)&#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">TestCode1</span>().start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">TestCode1</span>().start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h2><ul><li>实现Runnable接口，重写run方法，实例要作为Thread的target来创建对象，thread.start()（推荐这种，清洗可见）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建自定义类对象 线程任务对象</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr, <span class="string">&quot;小强&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;旺财 &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>或者在方法内直接重写</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        </span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;张宇:&quot;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start(); </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>直接lambda创建<strong>Runnable</strong>实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;张宇:&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h2><ol><li><p>创建Callable接口的实现类，并实现Call（）方法，该方法将作为线程执行体，且该方法有返回值，再创建Callable实现类的实例。从Java8开始，可以直接使用Lambda表达式创建Callable对象。</p></li><li><p>使用FutureTask来包装Callable对象，该FutureTask对象封装了该Callable对象的call方法的返回值。</p></li><li><p>使用FutureTask对象作为Thread对象的target创建并启动新线程。</p></li><li><p>调用FutureTask对象的get（）方法来获取子线程执行结束后的返回值。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;循环遍历i的值&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Callable</span> <span class="variable">myCallable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(myCallable);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;循环遍历i的值&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(()-&gt;&#123;</span><br><span class="line">            <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;循环变量i的值：&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;循环变量i的值：&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">20</span>)&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(task,<span class="string">&quot;有返回值的线程&quot;</span>).start();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程的返回值：&quot;</span>+task.get());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异同点和优缺点"><a href="#异同点和优缺点" class="headerlink" title="异同点和优缺点"></a>异同点和优缺点</h2><h3 id="异同点"><a href="#异同点" class="headerlink" title="异同点"></a>异同点</h3><ul><li><p>相同点</p><ul><li>都可以实现多线程</li><li>Runnable与Callable实现方式类似</li></ul></li><li><p>不同点</p><ul><li>Thread方式是通过继承来实现。</li><li>Runnable与Callable是通过实现接口方式创建线程。</li><li>Runnable与Callable<ul><li>因为通过FutureTask包装Callable接口，FutureTask有get方法可以获取返回值，所以只有这种方式创建的子线程有返回值。</li><li>run方法无法抛出异常，call方法可以抛出checked exception。</li><li>Callable和Runnable都可以应用于executors。而Thread类只支持Runnable.</li></ul></li></ul></li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><p>优点</p><ul><li><p>Thread</p><ul><li>编写简单，如果需要访问当前线程，则无须使用Thread.currentThread（）方法，直接使用this即可获得当前线程。</li></ul></li><li><p>Runnable与Callable</p><ul><li>可以继承其他类</li><li>多个线程可以共享一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li></ul></li></ul></li><li><p>缺点</p><ul><li>Thread<ul><li>继承的局限性，不能继承其他类</li></ul></li><li>Runnable与Callable<ul><li>编程稍稍复杂，如果需要访问当前线程，则必须使用Thread.currentThread（）方法。</li></ul></li></ul></li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用 java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进 程。 </p><h1 id="子线程执行完，主线程执行"><a href="#子线程执行完，主线程执行" class="headerlink" title="子线程执行完，主线程执行"></a>子线程执行完，主线程执行</h1><p>正常如1中的各种实现方式 <a href="##%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F">Local跳转方式</a>，<a href="">Shimo跳转方式</a>，主线程与子线程是争夺线程资源的，所以一般情况是会出现类似交替执行的状况。</p><h2 id="FutureTask来包装Callable对象"><a href="#FutureTask来包装Callable对象" class="headerlink" title="FutureTask来包装Callable对象"></a>FutureTask来包装Callable对象</h2><p>上方（ <a href="##%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3">Local跳转方式</a>，<a href="">Shimo跳转方式</a>）的这种是子线程无返回值的情况，这种情况下，子线程与多线程可以争夺线程资源，</p><p>如果为子线程添加返回值，使用 FutureTask来包装Callable对象，通过task.get()来获取返回值，主线程进行到task.get()时，如果子线程还在执行，没有返回，主线程就会子线程返回之前等待挂起。从而达到要求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCode3</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;((Callable&lt;Integer&gt;)()-&gt;&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;循环变量i的值：&quot;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;循环变量i的值：&quot;</span>+i);</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">20</span>)&#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task,<span class="string">&quot;有返回值的线程&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;子线程的返回值：&quot;</span>+task.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h2><p><a href="https://blog.csdn.net/u013425438/article/details/80205693?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3.pc_relevant_default&utm_relevant_index=6">参考资料链接</a></p><p>结论：t.join()方法只会使主线程(或者说调用t.join()的线程)进入等待池并等待t线程执行完毕后才会被唤醒。并不影响同一时刻处在运行状态的其他线程。</p><p>t.join方法底层中使用wait(0)方法，即使用了该方法的线程会进入无限等待中，直到 t 执行完成才返回。进入等待的只是调用了join方法的线程，其他线程没开启的不会开启，开启了的不会等待继续执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJoin</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot; start&quot;</span>);</span><br><span class="line">ThreadTest t1=<span class="keyword">new</span> <span class="title class_">ThreadTest</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">ThreadTest t2=<span class="keyword">new</span> <span class="title class_">ThreadTest</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">ThreadTest t3=<span class="keyword">new</span> <span class="title class_">ThreadTest</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;t1start&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">System.out.println(<span class="string">&quot;t1end&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;t2start&quot;</span>);</span><br><span class="line">t2.start();</span><br><span class="line">System.out.println(<span class="string">&quot;t2end&quot;</span>);</span><br><span class="line">t1.join();</span><br><span class="line">System.out.println(<span class="string">&quot;t3start&quot;</span>);</span><br><span class="line">t3.start();</span><br><span class="line">System.out.println(<span class="string">&quot;t3end&quot;</span>);</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot; end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">main start</span><br><span class="line">t1start</span><br><span class="line">t1end</span><br><span class="line">t2start</span><br><span class="line">t2end</span><br><span class="line">A-<span class="number">1</span></span><br><span class="line">B-<span class="number">1</span></span><br><span class="line">A-<span class="number">2</span></span><br><span class="line">A-<span class="number">3</span></span><br><span class="line">A-<span class="number">4</span></span><br><span class="line">A-<span class="number">5</span></span><br><span class="line">B-<span class="number">2</span></span><br><span class="line">t3start</span><br><span class="line">t3end</span><br><span class="line">B-<span class="number">3</span></span><br><span class="line">main end</span><br><span class="line">B-<span class="number">4</span></span><br><span class="line">B-<span class="number">5</span></span><br><span class="line">C-<span class="number">1</span></span><br><span class="line">C-<span class="number">2</span></span><br><span class="line">C-<span class="number">3</span></span><br><span class="line">C-<span class="number">4</span></span><br><span class="line">C-<span class="number">5</span></span><br></pre></td></tr></table></figure><p>主线程在t1.join()方法处停止，并需要等待A线程执行完毕后才会执行t3.start()，然而，并不影响B线程的执行。因此，可以得出结论，t.join()方法只会使主线程进入等待池并等待t线程执行完毕后才会被唤醒。并不影响同一时刻处在运行状态的其他线程。</p><blockquote><p>join源码中，只会调用wait方法，并没有在结束时调用notify，这是因为&#x3D;&#x3D;线程在die的时候会自动调用自身的notifyAll方法，来释放所有的资源和锁。&#x3D;&#x3D;</p></blockquote><h1 id="线程与线程池的状态"><a href="#线程与线程池的状态" class="headerlink" title="线程与线程池的状态"></a>线程与线程池的状态</h1><h2 id="线程的状态（NRBWTT）（牛肉包我舔舔）"><a href="#线程的状态（NRBWTT）（牛肉包我舔舔）" class="headerlink" title="线程的状态（NRBWTT）（牛肉包我舔舔）"></a>线程的状态（NRBWTT）（牛肉包我舔舔）</h2><ul><li>NEW                                                                 尚未启动</li><li>RUNNABLE                                         正在执⾏中</li><li>BLOCKED                                            阻塞的（被同步锁或者IO锁阻塞）</li><li>WAITING                                             永久等待状态</li><li>TIMED_WAITING                                 等待指定的时间重新被唤醒的状态</li><li>TERMINATED                                      执⾏完成</li></ul><p><img src="https://blogimg.ytte.top//img-jixiang//20220310230947.png"></p><h2 id="线程池的状态（RSSTT）（人事是傻甜甜）"><a href="#线程池的状态（RSSTT）（人事是傻甜甜）" class="headerlink" title="线程池的状态（RSSTT）（人事是傻甜甜）"></a>线程池的状态（RSSTT）（人事是傻甜甜）</h2><ol><li><p><em><strong>RUNNING： 这是最正常的状态</strong></em> ，接受新的任务，处理等待队列中的任务 。 </p></li><li><p><em><strong>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务</strong></em>。 </p></li><li><p><em><strong>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执⾏任务的线程。</strong></em></p></li><li><p><em><strong>TIDYING：所有的任务都销毁了</strong></em>，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执⾏钩⼦⽅法 terminated()。</p></li><li><p><strong>TERMINATED：terminated()⽅法结束后，线程池的状态就会变成这个。</strong></p></li></ol><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>大佬链接&#x3D;&#x3D;&#x3D;&#x3D;》<a href="https://blog.csdn.net/u013541140/article/details/95225769?ops_request_misc=%7B%22request_id%22:%22164683408616781685325229%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=164683408616781685325229&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-95225769.pc_search_result_cache&utm_term=%E7%BA%BF%E7%A8%8B%E6%B1%A0&spm=1018.2226.3001.4187">线程池1_CSDN博客</a></p><p>大佬链接&#x3D;&#x3D;&#x3D;&#x3D;》<a href="https://blog.csdn.net/qq_34115899/article/details/114531116?ops_request_misc=%7B%22request_id%22:%22164691607116780255229360%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=164691607116780255229360&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-114531116.pc_search_result_cache&utm_term=%E7%BA%BF%E7%A8%8B%E6%B1%A0&spm=1018.2226.3001.4187">线程池2-CSDN博客</a></p><h2 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h2><ul><li><p><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p></li><li><p><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p></li><li><p><strong>提高线程的可管理性。</strong>线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p></li></ul><h2 id="线程池的继承树"><a href="#线程池的继承树" class="headerlink" title="线程池的继承树"></a>线程池的继承树</h2><p><img src="https://blogimg.ytte.top//img-jixiang/20220310114635.png"></p><h2 id="线程池地使用"><a href="#线程池地使用" class="headerlink" title="线程池地使用"></a>线程池地使用</h2><p>线程池的真正实现类是ThreadPoolExecutor ，其构造器方法有以下4种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         threadFactory, defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), handler);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明：<a id ="线程池参数"> IPHP </a></p><ul><li><code>corePoolSize</code>（必需）：核心线程数。默认情况下，核心线程会一直存活，但是当将 <strong>allowCoreThreadTimeout</strong> 设置为 true 时，核心线程也会超时回收。</li><li><code>maximumPoolSize</code>（必需）：线程池所能容纳的最大线程数。当活跃线程数达到该数值后，后续的新任务将会阻塞。</li><li><code>keepAliveTime</code>（必需）：线程闲置超时时长。如果超过该时长，非核心线程就会被回收。如果将 <strong>allowCoreThreadTimeout</strong> 设置为 true 时，核心线程也会超时回收。</li><li><code>unit</code>（必需）：指定 keepAliveTime 参数的时间单位。常用的有：TimeUnit.MILLISECONDS（毫秒）、TimeUnit.SECONDS（秒）、TimeUnit.MINUTES（分）。</li><li><code>workQueue</code>（必需）：任务队列。通过线程池的 <strong>execute()</strong> 方法提交的 Runnable 对象将存储在该参数中。其采用阻塞队列实现。</li><li><code>threadFactory</code>（可选）：线程工厂。用于指定为线程池创建新线程的方式。</li><li><code>handler</code>（可选）：拒绝策略。当达到最大线程数时需要执行的饱和策略。</li></ul><p>线程池的使用流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(CORE_POOL_SIZE,</span><br><span class="line">                                             MAXIMUM_POOL_SIZE,</span><br><span class="line">                                             KEEP_ALIVE,</span><br><span class="line">                                             TimeUnit.SECONDS,</span><br><span class="line">                                             sPoolWorkQueue,</span><br><span class="line">                                             sThreadFactory);</span><br><span class="line"><span class="comment">// 向线程池提交任务</span></span><br><span class="line">threadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        ... <span class="comment">// 线程执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 关闭线程池</span></span><br><span class="line">threadPool.shutdown(); <span class="comment">// 设置线程池的状态为SHUTDOWN，然后中断所有没有正在执行任务的线程</span></span><br><span class="line">threadPool.shutdownNow(); <span class="comment">// 设置线程池的状态为 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表</span></span><br></pre></td></tr></table></figure><h2 id="线程池的工作原理"><a href="#线程池的工作原理" class="headerlink" title="线程池的工作原理"></a>线程池的工作原理</h2><p><img src="https://blogimg.ytte.top//img-jixiang//20220310160511.png"></p><p>简概：<a id ="线程池的工作原理"> IPHP </a></p><ul><li>1.如果线程数小于<code>corePoolSize</code>，创建一个新<strong>核心线程</strong>来运行新任务。</li><li>2.如果线程数大于等于<code>corePoolSize</code>但小于<code>maximumPoolSize</code>，则将任务放入队列。</li><li>3.如果队列已满，并且线程数小于<code>maxPoolSize</code>，则创建一个新<strong>非核心线程</strong>来运行任务。</li><li>4.如果队列已满，并且线程数大于或等于<code>maxPoolSize</code>，则拒绝该任务。</li></ul><p>是否需要增加线程的判断顺序是：1、<code>corePoolSize</code> 2、<code>workQueue</code> 3、<code>maxPoolSize</code></p><p><strong>举个例子：</strong></p><p>线程池的核心线程数<code>corePoolSize</code>大小为5，最大池<code>maxPoolSize</code>大小为10，队列<code>workQueue</code>为100。</p><p>因为线程中的请求最多会创建5个，然后任务将被添加到队列中，直到达到100。当队列已满时，将创建新的线程，最多到10个线程，如果再来任务，就拒绝。</p><p><strong>特点：</strong></p><ul><li>通过设置<code>corePoolSize</code>和<code>maximumPoolSize</code> 相同，就可以创建固定大小的线程池。</li><li>我们使用线程池一般希望保持较少的线程数，并且只有在负载变得很大时才增加它。</li><li>通过设置<code>maximumPoolSize</code>为很高的值，例如 <code>Integer.MAX_VALUE</code>，可以允许线程池容纳任意数量的并发任务。</li><li>只有在队列填满时才创建多于<code>corePoolSize</code>的非核心线程，如果使用的是无界队列（例如<code>LinkedBlockingQueue</code>），那么线程数就不会超过<code>corePoolSize</code>。</li></ul><h2 id="线程参数解析"><a href="#线程参数解析" class="headerlink" title="线程参数解析"></a>线程参数解析</h2><h3 id="任务队列workQueue"><a href="#任务队列workQueue" class="headerlink" title="任务队列workQueue"></a>任务队列workQueue</h3><p>任务队列是基于阻塞队列实现的，即采用生产者消费者模式，在 Java 中需要实现 BlockingQueue 接口。但 Java 已经为我们提供了 7 种阻塞队列的实现：</p><ul><li><p><code>ArrayBlockingQueue</code>：一个由数组结构组成的有界阻塞队列（数组结构可配合指针实现一个环形队列）。</p></li><li><p><code>LinkedBlockingQueue</code>： 一个由链表结构组成的有界阻塞队列，在未指明容量时，容量默认为Integer.MAX_VALUE。</p><blockquote><p>这种队列容量无限大，可以防止流量突增。设置<code>maximumPoolSize</code>也用不到，因为队列装不满，永远不需要创建新的非核心线程。但是也有风险，处理任务的速度跟不上提交的速度，可能造成内存浪费或者<code>OOM</code>。</p></blockquote></li><li><p><code>PriorityBlockingQueue</code>： 一个支持优先级排序的无界阻塞队列，对元素没有要求，可以实现 Comparable 接口也可以提供 Comparator 来对队列中的元素进行比较。跟时间没有任何关系，仅仅是按照优先级取任务。</p></li><li><p><code>DelayQueue</code>：类似于PriorityBlockingQueue，是二叉堆实现的无界优先级阻塞队列。要求元素都实现 Delayed 接口，通过执行时延从队列中提取任务，时间没到任务取不出来。</p></li><li><p><code>SynchronousQueue</code>： 一个不存储元素的阻塞队列，消费者线程调用 take() 方法的时候就会发生阻塞，直到有一个生产者线程生产了一个元素，消费者线程就可以拿到这个元素并返回；生产者线程调用 put() 方法的时候也会发生阻塞，直到有一个消费者线程消费了一个元素，生产者才会返回。</p><blockquote><p>工作任务不多的情况下，只是将任务中转，就可以用<code>SynchronousQueue</code>，这个队列本身内部没有容量，使用这种队列，<code>maximumPoolSize</code>就可能需要设置的大一些。因为没有队列容量作为缓冲了，很容易创建新线程。</p></blockquote></li><li><p><code>LinkedBlockingDeque</code>： 使用双向队列实现的有界双端阻塞队列。双端意味着可以像普通队列一样 FIFO（先进先出），也可以像栈一样 FILO（先进后出）。</p></li><li><p><code>LinkedTransferQueue</code>： 它是ConcurrentLinkedQueue、LinkedBlockingQueue 和 SynchronousQueue 的结合体，但是把它用在 ThreadPoolExecutor 中，和 LinkedBlockingQueue 行为一致，但是是无界的阻塞队列。</p></li></ul><p>注意有界队列和无界队列的区别：如果使用有界队列，当队列饱和时并超过最大线程数时就会执行拒绝策略；而如果使用无界队列，因为任务队列永远都可以添加任务，所以设置 maximumPoolSize 没有任何意义。</p><h3 id="线程工厂（threadFactory）"><a href="#线程工厂（threadFactory）" class="headerlink" title="线程工厂（threadFactory）"></a>线程工厂（threadFactory）</h3><p>线程工厂指定创建线程的方式，需要实现 <strong>ThreadFactory</strong> 接口，并实现 <strong>newThread(Runnable r)</strong> 方法。</p><ol><li>新的线程是由<code>ThreadFactory</code>创建的，默认使用<code>Executors.defaultThreadFactory()</code></li><li>创建出来的线程都在同一个线程组，拥有同样的<code>NORM_PRIORITY</code>优先级并且都不是守护线程。</li><li>如果自己指定<code>ThreadFactory</code>，那么就可以改变线程名、线程组、优先级、是否是守护线程等。</li><li>通常使用默认的<code>ThreadFactory</code>就可以了</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证第一点，新的线程是由ThreadFactory创建的，默认使用Executors.defaultThreadFactory()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title function_">defaultThreadFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultThreadFactory</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">poolNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">        DefaultThreadFactory() &#123;</span><br><span class="line">            <span class="type">SecurityManager</span> <span class="variable">s</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">            group = (s != <span class="literal">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                                  Thread.currentThread().getThreadGroup();</span><br><span class="line">            namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                          poolNumber.getAndIncrement() +</span><br><span class="line">                         <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="comment">// 验证第二点，创建出来的线程都在同一个线程组，拥有同样的NORM_PRIORITY优先级并且都不是守护线程。</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, r,</span><br><span class="line">                                  namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                                  <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">                t.setDaemon(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="拒绝策略（handler）"><a href="#拒绝策略（handler）" class="headerlink" title="拒绝策略（handler）"></a>拒绝策略（handler）</h3><p>当线程池的线程数达到最大线程数时，需要执行拒绝策略。拒绝策略需要实现 RejectedExecutionHandler 接口，并实现 rejectedExecution(Runnable r, ThreadPoolExecutor executor) 方法。不过 Executors 框架已经为我们实现了 4 种拒绝策略：</p><ul><li><strong>AbortPolicy（默认）</strong>：丢弃任务并抛出 RejectedExecutionException 异常。</li><li><strong>CallerRunsPolicy</strong>：由调用线程处理该任务。</li><li><strong>DiscardPolicy</strong>：丢弃任务，但是不抛出异常。可以配合这种模式进行自定义的处理方式。</li><li><strong>DiscardOldestPolicy</strong>：丢弃队列最早的未处理任务，然后重新尝试执行任务。</li></ul><h2 id="功能线程池"><a href="#功能线程池" class="headerlink" title="功能线程池"></a>功能线程池</h2><p>嫌上面使用线程池的方法太麻烦？其实Executors已经为我们封装好了 4 种常见的功能线程池，如下：</p><ul><li>定长线程池（FixedThreadPool）</li><li>定时线程池（ScheduledThreadPool ）</li><li>可缓存线程池（CachedThreadPool）</li><li>单线程化线程池（SingleThreadExecutor）</li></ul><h3 id="定长线程池（FixedThreadPool）"><a href="#定长线程池（FixedThreadPool）" class="headerlink" title="定长线程池（FixedThreadPool）"></a>定长线程池（FixedThreadPool）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>特点</strong>：只有核心线程，<strong>线程数量固定</strong>，执行完立即回收，任务队列为链表结构的有界队列。</li><li><strong>应用场景</strong>：控制线程最大并发数。</li></ul><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建定长线程池对象 &amp; 设置线程池线程数量固定为3</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">fixedThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 2. 创建好Runnable类线程对象 &amp; 需执行的任务</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;执行任务啦&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 3. 向线程池提交任务</span></span><br><span class="line">fixedThreadPool.execute(task);</span><br></pre></td></tr></table></figure><h3 id="定时线程池（ScheduledThreadPool-）"><a href="#定时线程池（ScheduledThreadPool-）" class="headerlink" title="定时线程池（ScheduledThreadPool ）"></a>定时线程池（ScheduledThreadPool ）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">DEFAULT_KEEPALIVE_MILLIS</span> <span class="operator">=</span> <span class="number">10L</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">int</span> corePoolSize, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                                   ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>(), threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>特点</strong>：核心线程数量固定，非核心线程数量无限，执行完闲置 10ms 后回收，任务队列为延时阻塞队列。</li><li><strong>应用场景</strong>：执行定时或周期性的任务。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建 定时线程池对象 &amp; 设置线程池线程数量固定为5</span></span><br><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">scheduledThreadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 2. 创建好Runnable类线程对象 &amp; 需执行的任务</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;执行任务啦&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 3. 向线程池提交任务</span></span><br><span class="line">scheduledThreadPool.schedule(task, <span class="number">1</span>, TimeUnit.SECONDS); <span class="comment">// 延迟1s后执行任务</span></span><br><span class="line">scheduledThreadPool.scheduleAtFixedRate(task,<span class="number">10</span>,<span class="number">1000</span>,TimeUnit.MILLISECONDS);<span class="comment">// 延迟10ms后、每隔1000ms执行任务</span></span><br></pre></td></tr></table></figure><h3 id="可缓存线程池（CachedThreadPool）"><a href="#可缓存线程池（CachedThreadPool）" class="headerlink" title="可缓存线程池（CachedThreadPool）"></a>可缓存线程池（CachedThreadPool）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>特点</strong>：无核心线程，非核心线程数量无限，执行完闲置 60s 后回收，任务队列为不存储元素的阻塞队列。</li><li><strong>应用场景</strong>：执行大量、耗时少的任务。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建可缓存线程池对象</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">cachedThreadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">// 2. 创建好Runnable类线程对象 &amp; 需执行的任务</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;执行任务啦&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 3. 向线程池提交任务</span></span><br><span class="line">cachedThreadPool.execute(task)</span><br></pre></td></tr></table></figure><h3 id="单线程化线程池（SingleThreadExecutor）"><a href="#单线程化线程池（SingleThreadExecutor）" class="headerlink" title="单线程化线程池（SingleThreadExecutor）"></a>单线程化线程池（SingleThreadExecutor）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>特点</strong>：只有 1 个核心线程，无非核心线程，执行完立即回收，任务队列为链表结构的有界队列。</li><li><strong>应用场景</strong>：不适合并发但可能引起 IO 阻塞性及影响 UI 线程响应的操作，如数据库操作、文件操作等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建单线程化线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">singleThreadExecutor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">// 2. 创建好Runnable类线程对象 &amp; 需执行的任务</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;执行任务啦&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 3. 向线程池提交任务</span></span><br><span class="line">singleThreadExecutor.execute(task);</span><br></pre></td></tr></table></figure><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><img src="https://blogimg.ytte.top//img-jixiang//20220310203126.png"></p><h1 id="线程池模板"><a href="#线程池模板" class="headerlink" title="线程池模板"></a>线程池模板</h1><p>大佬链接&#x3D;&#x3D;&#x3D;&#x3D;》<a href="https://www.cnblogs.com/keeya/archive/2018/11/27/10025260.html">Spring线程池配置模板- 博客园 </a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogThreadPoolConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean(name = &quot;logThreadPool&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">LogThreadPoolTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">    <span class="type">LogThreadPoolProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="built_in">this</span>.logThreadPoolProperties();</span><br><span class="line"></span><br><span class="line">    executor.setCorePoolSize(properties.getCorePoolSize());</span><br><span class="line">    executor.setMaxPoolSize(properties.getMaxPoolSize());</span><br><span class="line">    executor.setQueueCapacity(properties.getQueueCapacity());</span><br><span class="line">    executor.setKeepAliveSeconds(properties.getKeepAliveSeconds());</span><br><span class="line">    executor.setThreadNamePrefix(properties.getThreadName());</span><br><span class="line">    <span class="keyword">switch</span> (properties.getRejectedExecutionHandler()) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;abortPolicy&quot;</span>:</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">AbortPolicy</span>());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;callerRunsPolicy&quot;</span>:</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">CallerRunsPolicy</span>());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;discardOldestPolicy&quot;</span>:</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">DiscardOldestPolicy</span>());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;discardPolicy&quot;</span>:</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">DiscardOldestPolicy</span>());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">CallerRunsPolicy</span>());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    executor.initialize();</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConfigurationProperties(prefix = &quot;threadpool.log&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> LogThreadPoolProperties <span class="title function_">logThreadPoolProperties</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LogThreadPoolProperties</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//@Getter lombok提供的getset方法生成注解</span></span><br><span class="line">  <span class="comment">//@Setter</span></span><br><span class="line">  <span class="meta">@Configuration</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LogThreadPoolProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程前缀名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 核心线程池大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> corePoolSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxPoolSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> queueCapacity;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池维护空闲线程存在时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> keepAliveSeconds;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拒绝策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String rejectedExecutionHandler;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以在yml文件中配置参数了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">threadpool:</span></span><br><span class="line">  <span class="attr">log:</span></span><br><span class="line">    <span class="attr">threadName:</span> <span class="string">ThreadPool-log-</span> <span class="comment"># 线程池前缀名</span></span><br><span class="line">    <span class="attr">corePoolSize:</span> <span class="number">8</span>             <span class="comment"># 核心线程池数：IO型推荐设置为cpu核心数*2；cpu型推荐设置为cpu数+1</span></span><br><span class="line">    <span class="attr">maxPoolSize:</span> <span class="number">16</span>             <span class="comment"># 最大线程池数</span></span><br><span class="line">    <span class="attr">queueCapacity:</span> <span class="number">1000</span>         <span class="comment"># 线程池阻塞队列容量</span></span><br><span class="line">    <span class="attr">keepAliveSeconds:</span> <span class="number">60</span>        <span class="comment"># 允许线程空闲时间</span></span><br><span class="line">    <span class="comment"># 拒绝策略 abortPolicy callerRunsPolicy discardOldestPolicy discardPolicy</span></span><br><span class="line">    <span class="attr">rejectedExecutionHandler:</span> <span class="string">callerRunsPolicy</span></span><br></pre></td></tr></table></figure><p>使用：</p><p>Spring提供了注解方式来方便我们使用线程池，只需要在要异步处理的方法上加 @Async(“你配置的线程池名字”)就可以了,注意这个类需要被spring扫描并纳入管理，所以要加@Service、@Component等注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@Async(&quot;logThreadPool&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOperationLog</span><span class="params">(BaseLog baseLog)</span> &#123;</span><br><span class="line">    <span class="comment">//你要异步执行的逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h1><ol><li>&#x3D;&#x3D;Executors 的 4 个功能线程池虽然方便，但现在已经不建议使用了，而是建议直接通过使用 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。&#x3D;&#x3D;</li></ol><p>其实 Executors 的 4 个功能线程有如下弊端：</p><ul><li><strong>FixedThreadPool</strong> 和 <strong>SingleThreadExecutor</strong>：主要问题是堆积的请求处理队列均采用 <strong>LinkedBlockingQueue</strong>，可能会耗费非常大的内存，甚至 OOM。</li><li><strong>CachedThreadPool</strong> 和 <strong>ScheduledThreadPool</strong>：主要问题是线程数最大数是 <strong>Integer.MAX_VALUE</strong>，可能会创建数量非常多的线程，甚至 OOM。</li></ul><ol start="2"><li>线程池里的线程数量设定为多少比较合适？</li></ol><p>这个得看任务类型</p><ul><li><code>CPU</code>密集型（加密、计算<code>hash</code>等）：最佳线程数为<code>CPU</code>核心数的1-2倍左右。</li><li>耗时<code>IO</code>型（读写数据库、文件、网络读写等）：最佳线程数一般会大于<code>CPU</code>核心数很多倍 ，参考<code>Brain Goetz</code>专家推荐的计算方法：线程数&#x3D;<code>CPU</code>核心数*（1+平均等待时间&#x2F;平均工作时间）</li></ul><p>如果需要更精确的线程数量，那就需要根据不同的程序去做压测，这样就能得到比较合适的线程数量。</p><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>ThreadLocal叫做<em><strong>线程变量</strong></em>，ThreadLocal中<em><strong>填充的变量</strong></em> 属于<em><strong>当前线程</strong></em>，该变量对其他线程而言是隔离的。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p><p>ThreadLocal 适用于每个线程变量在线程间隔离而在方法或类间共享的场景。</p><p><img src="https://blogimg.ytte.top//img-jixiang//20220311113857.png"></p><h2 id="ThreadLocal与Synchronized的区别"><a href="#ThreadLocal与Synchronized的区别" class="headerlink" title="ThreadLocal与Synchronized的区别"></a>ThreadLocal与Synchronized的区别</h2><ul><li><p>ThreadLocal</p><p>ThreadLocal则用于线程间的数据隔离。ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象</p></li><li><p>Synchronized</p><p>Synchronized用于线程间的数据共享。利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。</p></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocaDemo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; localVar = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;String&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">//打印当前线程中本地内存中本地变量的值</span></span><br><span class="line">        System.out.println(str + <span class="string">&quot; :&quot;</span> + localVar.get());</span><br><span class="line">        <span class="comment">//清除本地内存中的本地变量</span></span><br><span class="line">        localVar.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                ThreadLocaDemo.localVar.set(<span class="string">&quot;local_A&quot;</span>);</span><br><span class="line">                print(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">                <span class="comment">//打印本地变量</span></span><br><span class="line">                System.out.println(<span class="string">&quot;after remove : &quot;</span> + localVar.get());</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"> </span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                ThreadLocaDemo.localVar.set(<span class="string">&quot;local_B&quot;</span>);</span><br><span class="line">                print(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;after remove : &quot;</span> + localVar.get());</span><br><span class="line">              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">A :local_A</span><br><span class="line">after remove : <span class="literal">null</span></span><br><span class="line">B :local_B</span><br><span class="line">after remove : <span class="literal">null</span></span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p>&#x3D;&#x3D;向ThreadLocal里面存东西就是向它里面的Map存东西的，然后ThreadLocal把这个Map挂到当前的线程底下&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">       <span class="comment">//1、获取当前线程</span></span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">       <span class="comment">//2、获取线程中的属性 threadLocalMap ,如果threadLocalMap 不为空，</span></span><br><span class="line">       <span class="comment">//则直接更新要保存的变量值，否则创建threadLocalMap，并赋值</span></span><br><span class="line">       <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">           map.set(<span class="built_in">this</span>, value);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="comment">// 初始化thradLocalMap 并赋值</span></span><br><span class="line">           createMap(t, value);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 从上面的代码可以看出，ThreadLocal  set赋值的时候首先会获取当前线程thread,并获取thread线程中的ThreadLocalMap属性。如果map属性不为空，则直接更新value值，如果map为空，则实例化threadLocalMap,并将value值初始化。</p><p>&#x3D;&#x3D;ThreadLocalMap呢是当前线程Thread一个叫threadLocals的变量中获取的。每个线程Thread都维护了自己的threadLocals变量，所以在每个线程创建ThreadLocal的时候，实际上数据是存在自己线程Thread的threadLocals变量里面的，别人没办法拿到，从而实现了隔离。&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">       * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">       * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">       * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">       * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">       * as &quot;stale entries&quot; in the code that follows.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">          <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">          Object value;</span><br><span class="line"> </span><br><span class="line">          Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">              <span class="built_in">super</span>(k);</span><br><span class="line">              value = v;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可看出ThreadLocalMap是ThreadLocal的内部静态类，而它的构成主要是用Entry来保存数据 ，而且还是继承的弱引用。在Entry内部使用ThreadLocal作为key，使用我们设置的value作为value。<a id ="ThreadLocalMap">IPHP</a></p><p>姬祥todo createMap</p><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1、获取当前线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">//2、获取当前线程的ThreadLocalMap</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="comment">//3、如果map数据为空，</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//3.1、获取threalLocalMap中存储的值</span></span><br><span class="line">            ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是数据为null，则初始化，初始化的结果，TheralLocalMap中存放key值为threadLocal，值为null</span></span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">         <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">             m.remove(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remove方法，直接将ThrealLocal 对应的值从当前相差Thread中的ThreadLocalMap中删除。为什么要删除，这涉及到内存泄露的问题。</p><p>如上所说（<a href="#ThreadLocalMap">Local跳转方式</a>，<a href="">Shimo跳转方式</a>）， ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉。</p><p>所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。这样就造成了内存泄露。</p><h2 id="ThreadLocal与Thread，ThreadLocalMap之间的关系"><a href="#ThreadLocal与Thread，ThreadLocalMap之间的关系" class="headerlink" title="ThreadLocal与Thread，ThreadLocalMap之间的关系"></a>ThreadLocal与Thread，ThreadLocalMap之间的关系</h2><p><img src="https://blogimg.ytte.top//img-jixiang//20220311184831.png"></p><p><img src="https://blogimg.ytte.top//img-jixiang//20220311184917.png"></p><h2 id="ThreadLocal-常见使用场景"><a href="#ThreadLocal-常见使用场景" class="headerlink" title="ThreadLocal 常见使用场景"></a>ThreadLocal 常见使用场景</h2><p>参考&#x3D;&#x3D;&#x3D;&#x3D;》<a href="https://www.cnblogs.com/zz-ksw/p/12684877.html#!comments">ThreadLocal的应用场景 - sw_kong - 博客园 (cnblogs.com)</a></p><p>场景的需求：</p><ul><li>每个线程需要有自己单独的实例</li><li>实例需要在多个方法中共享，但不希望变量被多线程共享</li><li>ThreadLocal 用作每个线程内需要独立保存信息，以便供其他方法更方便地获取该信息的场景。每个线程获取到的信息可能都是不一样的，前面执行的方法保存了信息后，后续方法可以通过ThreadLocal 直接获取到，避免了传参，类似于全局变量的概念。</li></ul><h3 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a><strong>SimpleDateFormat</strong></h3><p>（Java8里的 java.time.format.DateTimeFormatter 是线程安全的 ，由于它调用的parseResolved0 方法入参都是final 修饰的，不可变变量是线程安全的。）</p><p>当时我们使用SimpleDataFormat的parse()方法，内部有一个Calendar对象，调用SimpleDataFormat的parse()方法会先调用Calendar.clear（），然后调用Calendar.add()。<a href="https://blog.csdn.net/qq_35190492/article/details/107599875?ops_request_misc=%7B%22request_id%22:%22164696626016781683978633%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=164696626016781683978633&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-107599875.pc_search_result_cache&utm_term=ThreadLocal&spm=1018.2226.3001.4187">ThreadLocal_敖丙-CSDN博客</a>。如果一个线程先调用了add()然后另一个线程又调用了clear()，这时候parse()方法解析的时间就不对了。</p><p>在这种情况下，每个Thread内都有自己的实例副本，且该副本只能由当前Thread访问到并使用，相当于每个线程内部的本地变量，这也是ThreadLocal命名的含义。因为每个线程独享副本，而不是公用的，所以不存在多线程间共享的问题。</p><p>比如有<strong>1000</strong>个线程都要用到SimpleDateFormat</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo011</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.submit(() -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalDemo011</span>().date(finalI);</span><br><span class="line">                System.out.println(data);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer id= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">date</span><span class="params">(<span class="type">int</span> seconds)</span>&#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1000</span> * seconds);</span><br><span class="line">        id++;</span><br><span class="line">        System.out.println(id+<span class="string">&quot;=============&quot;</span>);</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;mm:ss&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> simpleDateFormat.format(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，我们用了一个16线程的线程池，并且给这个线程池提交了1000次任务。每个任务中它做的事情和之前是一样的，还是去执行date方法，并且在这个方法中创建一个simpleDateFormat 对象。近1000个simpleDateFormat 对象会被创建。</p><p>这么多对象的创建是有开销的，并且在使用完之后的销毁同样是有开销的，同时存在在内存中也是一种内存的浪费。</p><p>我们可能会想到，要不所有的线程共用一个 simpleDateFormat 对象？但是simpleDateFormat 又不是线程安全的，我们必须做同步，比如使用synchronized加锁。到这里也许就是我们最终的一个解决方法。但是使用synchronized加锁会陷入一种排队的状态，多个线程不能同时工作，这样一来，整体的效率就被大大降低了。</p><ul><li>使用ThreadLocal</li></ul><p>对这种场景，ThreadLocal再合适不过了，ThreadLocal给每个线程维护一个自己的simpleDateFormat对象，这个对象在线程之间是独立的，互相没有关系的。这也就避免了线程安全问题。与此同时，simpleDateFormat对象还不会创造过多，线程池一共只有 16 个线程，所以需要16个对象即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo04</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.submit(() -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalDemo04</span>().date(finalI);</span><br><span class="line">                System.out.println(data);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">date</span><span class="params">(<span class="type">int</span> seconds)</span>&#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1000</span> * seconds);</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> ThreadSafeFormater.dateFormatThreadLocal.get();</span><br><span class="line">        <span class="keyword">return</span> dateFormat.format(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafeFormater</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer id= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">        id++;</span><br><span class="line">        System.out.println(id+<span class="string">&quot;=============&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;mm:ss&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>结果：</p><p>可以看出只创建了16个SimpleDateFormat对象。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1=============</span><br><span class="line">4=============</span><br><span class="line">5=============</span><br><span class="line">6=============</span><br><span class="line">3=============</span><br><span class="line">7=============</span><br><span class="line">2=============</span><br><span class="line">8=============</span><br><span class="line">9=============</span><br><span class="line">10=============</span><br><span class="line">11=============</span><br><span class="line">13=============</span><br><span class="line">12=============</span><br><span class="line">14=============</span><br><span class="line">15=============</span><br><span class="line">16=============</span><br><span class="line">00:09</span><br><span class="line">00:16</span><br><span class="line">00:17</span><br><span class="line">........</span><br><span class="line">........</span><br><span class="line">16:05</span><br><span class="line">16:04</span><br><span class="line">16:03</span><br><span class="line">16:02</span><br></pre></td></tr></table></figure><ul><li>问题：<ul><li>这种情况每个线程的SimpleDataFormat的parse()方法，在一个任务执行后其他任务继续使用这个线程执行任务时，会不会造成数据混乱。</li></ul></li><li>答案<ul><li>不会，SimpleDataFormat的parse()方法，内部有一个Calendar对象，调用SimpleDataFormat的parse()方法会先调用Calendar.clear()清除数据，然后调用Calendar.add()添加数据。</li></ul></li></ul><h3 id="用户信息（类似线程内的全局变量）"><a href="#用户信息（类似线程内的全局变量）" class="headerlink" title="用户信息（类似线程内的全局变量）"></a>用户信息（类似线程内的全局变量）</h3><p>每个线程内需要保存类似于全局变量的信息（例如在拦截器中获取的用户信息），可以让不同方法直接使用，避免参数传递的麻烦却不想被多线程共享（因为不同线程获取到的用户信息不一样）。</p><p>例如，用 ThreadLocal 保存一些业务内容（用户权限信息、从用户系统获取到的用户名、用户ID 等），这些信息在同一个线程内相同，但是不同的线程使用的业务内容是不相同的。</p><p>在线程生命周期内，都通过这个静态 ThreadLocal 实例的 get() 方法取得自己 set 过的那个对象，避免了将这个对象（如 user 对象）作为参数传递的麻烦。</p><p>比如说我们是一个用户系统，那么当一个请求进来的时候，一个线程会负责执行这个请求，然后这个请求就会依次调用service-1()、service-2()、service-3()、service-4()，这4个方法可能是分布在不同的类中的。</p><p><img src="https://blogimg.ytte.top//img-jixiang//20220312212450.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kong.threadlocal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Service1</span>().service1(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Service1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service1</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        <span class="comment">//给ThreadLocal赋值，后续的服务直接通过ThreadLocal获取就行了。</span></span><br><span class="line">        UserContextHolder.holder.set(user);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Service2</span>().service2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Service2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> UserContextHolder.holder.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;service2拿到的用户:&quot;</span>+user.name);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Service3</span>().service3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Service3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> UserContextHolder.holder.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;service3拿到的用户:&quot;</span>+user.name);</span><br><span class="line">        <span class="comment">//在整个流程执行完毕后，一定要执行remove</span></span><br><span class="line">        UserContextHolder.holder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserContextHolder</span> &#123;</span><br><span class="line">    <span class="comment">//创建ThreadLocal保存User对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;User&gt; holder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="线程池创建的4中方法"><a href="#线程池创建的4中方法" class="headerlink" title="线程池创建的4中方法"></a>线程池创建的4中方法</h2><p><a href="#6%E3%80%81%E5%8A%9F%E8%83%BD%E7%BA%BF%E7%A8%8B%E6%B1%A0">Local跳转方式</a>，<a href="">Shimo跳转方式</a></p><h2 id="任务加入的线程池的流程"><a href="#任务加入的线程池的流程" class="headerlink" title="任务加入的线程池的流程"></a>任务加入的线程池的流程</h2><p><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">Local跳转方式</a>，<a href="">Shimo跳转方式</a></p><h2 id="线程池的7个参数。拒绝策略。"><a href="#线程池的7个参数。拒绝策略。" class="headerlink" title="线程池的7个参数。拒绝策略。"></a>线程池的7个参数。拒绝策略。</h2><p>参数：<a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0">Local跳转方式</a>，<a href="">Shimo跳转方式</a></p><p>拒绝策略：<a href="#3.%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%EF%BC%88handler%EF%BC%89">Local跳转方式</a>，<a href="">Shimo跳转方式</a></p><h2 id="线程池中如何拿到线程的执行结果"><a href="#线程池中如何拿到线程的执行结果" class="headerlink" title="线程池中如何拿到线程的执行结果"></a>线程池中如何拿到线程的执行结果</h2><h2 id="线程池中-submit-和-execute-方法有什么区别？"><a href="#线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="线程池中 submit()和 execute()方法有什么区别？"></a>线程池中 submit()和 execute()方法有什么区别？</h2><ul><li><p>execute()：只能执⾏ Runnable 类型的任务。</p></li><li><p>submit()：可以执⾏ Runnable 和 Callable 类型的任务。</p></li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>两线程都有各自的锁，并都尝试去获取独占对方的锁，就会发生阻塞的现象。</p><h2 id="解释下生产消费模型"><a href="#解释下生产消费模型" class="headerlink" title="解释下生产消费模型"></a>解释下生产消费模型</h2><p>生产者消费者能够解决的问题如下：</p><ul><li>生产与消费的速度不匹配</li><li>软件开发过程中解耦</li></ul><p>生产者生产，消费者消费，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架满的时候，消费者可以从货架上拿走商品，生产者此时等待货架的空位，这样不断的循环。那么在这个过程中，生产者和消费者是不直接接触的，所谓的‘货架’其实就是一个&#x3D;&#x3D;阻塞队列&#x3D;&#x3D;，生产者生产的产品不直接给消费者消费，而是仍给阻塞队列，这个阻塞队列就是来解决生产者消费者的强耦合的。就是生产者消费者模型。<a href="https://blog.csdn.net/qq_40550018/article/details/87859399?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4.pc_relevant_default&utm_relevant_index=9">TP①</a>，<a href="">TP②</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.cnblogs.com/luxiaoxun/p/8744826.html">ThreadLocal原理分析与使用场景 - 阿凡卢 - 博客园 (cnblogs.com)</a></li><li><a href="https://www.cnblogs.com/zz-ksw/p/12684877.html#!comments">ThreadLocal的应用场景 - sw_kong - 博客园 (cnblogs.com)</a></li><li><a href="https://blog.csdn.net/qq_35190492/article/details/107599875?ops_request_misc=%7B%22request_id%22:%22164696626016781683978633%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=164696626016781683978633&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-107599875.pc_search_result_cache&utm_term=ThreadLocal&spm=1018.2226.3001.4187">ThreadLocal_敖丙-CSDN博客</a></li><li><a href="https://blog.csdn.net/qq_40550018/article/details/87859399?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4.pc_relevant_default&utm_relevant_index=9"> CSDN博客_生产者消费者模型</a></li><li><a href="https://www.cnblogs.com/SIHAIloveYAN/p/11288064.html">Java8之Consumer、Supplier、Predicate和Function攻略  博客园</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;线程的实现方式及其优缺点&quot;&gt;&lt;a href=&quot;#线程的实现方式及其优缺点&quot; class=&quot;headerlink&quot; title=&quot;线程的实现方式及其优缺点&quot;&gt;&lt;/a&gt;线程的实现方式及其优缺点&lt;/h1&gt;&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="java" scheme="https://example.com/categories/java/"/>
    
    
    <category term="Thread" scheme="https://example.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud alibaba</title>
    <link href="https://example.com/2022/03/19/SpringCloud-alibaba/"/>
    <id>https://example.com/2022/03/19/SpringCloud-alibaba/</id>
    <published>2022-03-19T05:20:02.949Z</published>
    <updated>2022-03-19T05:19:18.107Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="SpringCloud-alibaba"><a href="#SpringCloud-alibaba" class="headerlink" title="SpringCloud alibaba"></a>SpringCloud alibaba</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;SpringCloud-alibaba&quot;&gt;&lt;a href=&quot;#SpringCloud-alibaba&quot; class=&quot;headerlink&quot; title=&quot;SpringCloud alibaba&quot;&gt;&lt;/a&gt;Spri</summary>
      
    
    
    
    <category term="java" scheme="https://example.com/categories/java/"/>
    
    
    <category term="SpringCloud" scheme="https://example.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot</title>
    <link href="https://example.com/2022/03/19/Springboot/"/>
    <id>https://example.com/2022/03/19/Springboot/</id>
    <published>2022-03-19T05:20:02.947Z</published>
    <updated>2022-03-19T06:53:40.694Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h1 id="5-web开发"><a href="#5-web开发" class="headerlink" title="5. web开发"></a>5. web开发</h1><h2 id="3-请求参数处理"><a href="#3-请求参数处理" class="headerlink" title="3.  请求参数处理"></a>3.  请求参数处理</h2><h3 id="1-普通参数与基本注解"><a href="#1-普通参数与基本注解" class="headerlink" title="1. 普通参数与基本注解"></a>1. 普通参数与基本注解</h3><h4 id="1-1注解"><a href="#1-1注解" class="headerlink" title="1.1注解"></a>1.1注解</h4><p>视频&#x3D;&#x3D;&#x3D;&#x3D;》<a href="https://www.bilibili.com/video/BV19K4y1L7MT?p=31">尚硅谷雷神SpringBoot2_bilibili</a></p><p>@PathVariable、</p><p>@RequestHeader、</p><p>@ModelAttribute、</p><p>@RequestParam、</p><p>@MatrixVariable（矩阵变量）、</p><p>@CookieValue、</p><p>@RequestBody</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParameterTestController</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  car/2/owner/zhangsan</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">getCar</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id,</span></span><br><span class="line"><span class="params">                                     <span class="meta">@PathVariable(&quot;username&quot;)</span> String name,</span></span><br><span class="line"><span class="params">                                     <span class="meta">@PathVariable</span> Map&lt;String,String&gt; pv,</span></span><br><span class="line"><span class="params">                                     <span class="meta">@RequestHeader(&quot;User-Agent&quot;)</span> String userAgent,</span></span><br><span class="line"><span class="params">                                     <span class="meta">@RequestHeader</span> Map&lt;String,String&gt; header,</span></span><br><span class="line"><span class="params">                                     <span class="meta">@RequestParam(&quot;age&quot;)</span> Integer age,</span></span><br><span class="line"><span class="params">                                     <span class="meta">@RequestParam(&quot;inters&quot;)</span> List&lt;String&gt; inters,</span></span><br><span class="line"><span class="params">                                     <span class="meta">@RequestParam</span> Map&lt;String,String&gt; params,</span></span><br><span class="line"><span class="params">                                     <span class="meta">@CookieValue(&quot;_ga&quot;)</span> String _ga,</span></span><br><span class="line"><span class="params">                                     <span class="meta">@CookieValue(&quot;_ga&quot;)</span> Cookie cookie)</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        map.put(&quot;id&quot;,id);</span></span><br><span class="line"><span class="comment">//        map.put(&quot;name&quot;,name);</span></span><br><span class="line"><span class="comment">//        map.put(&quot;pv&quot;,pv);</span></span><br><span class="line"><span class="comment">//        map.put(&quot;userAgent&quot;,userAgent);</span></span><br><span class="line"><span class="comment">//        map.put(&quot;headers&quot;,header);</span></span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>,age);</span><br><span class="line">        map.put(<span class="string">&quot;inters&quot;</span>,inters);</span><br><span class="line">        map.put(<span class="string">&quot;params&quot;</span>,params);</span><br><span class="line">        map.put(<span class="string">&quot;_ga&quot;</span>,_ga);</span><br><span class="line">        System.out.println(cookie.getName()+<span class="string">&quot;===&gt;&quot;</span>+cookie.getValue());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map <span class="title function_">postMethod</span><span class="params">(<span class="meta">@RequestBody</span> String content)</span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;content&quot;</span>,content);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、语法： 请求路径：/cars/sell;low=34;brand=byd,audi,yd</span></span><br><span class="line">    <span class="comment">//2、SpringBoot默认是禁用了矩阵变量的功能</span></span><br><span class="line">    <span class="comment">//      手动开启：原理。对于路径的处理。UrlPathHelper进行解析。</span></span><br><span class="line">    <span class="comment">//              removeSemicolonContent（移除分号内容）支持矩阵变量的</span></span><br><span class="line">    <span class="comment">//3、矩阵变量必须有url路径变量才能被解析</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/cars/&#123;path&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map <span class="title function_">carsSell</span><span class="params">(<span class="meta">@MatrixVariable(&quot;low&quot;)</span> Integer low,</span></span><br><span class="line"><span class="params">                        <span class="meta">@MatrixVariable(&quot;brand&quot;)</span> List&lt;String&gt; brand,</span></span><br><span class="line"><span class="params">                        <span class="meta">@PathVariable(&quot;path&quot;)</span> String path)</span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;low&quot;</span>,low);</span><br><span class="line">        map.put(<span class="string">&quot;brand&quot;</span>,brand);</span><br><span class="line">        map.put(<span class="string">&quot;path&quot;</span>,path);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// /boss/1;age=20/2;age=10</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/boss/&#123;bossId&#125;/&#123;empId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map <span class="title function_">boss</span><span class="params">(<span class="meta">@MatrixVariable(value = &quot;age&quot;,pathVar = &quot;bossId&quot;)</span> Integer bossAge,</span></span><br><span class="line"><span class="params">                    <span class="meta">@MatrixVariable(value = &quot;age&quot;,pathVar = &quot;empId&quot;)</span> Integer empAge)</span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;bossAge&quot;</span>,bossAge);</span><br><span class="line">        map.put(<span class="string">&quot;empAge&quot;</span>,empAge);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;SpringBoot&quot;&gt;&lt;a href=&quot;#SpringBoot&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot&quot;&gt;&lt;/a&gt;SpringBoot&lt;/h1&gt;&lt;h1 id=&quot;5-web开发&quot;</summary>
      
    
    
    
    <category term="java" scheme="https://example.com/categories/java/"/>
    
    
    <category term="SpringBoot" scheme="https://example.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://example.com/2022/03/19/MySQL/"/>
    <id>https://example.com/2022/03/19/MySQL/</id>
    <published>2022-03-19T05:20:02.939Z</published>
    <updated>2022-03-19T06:57:59.606Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1><h1 id="8、-索引的创建与设计原则"><a href="#8、-索引的创建与设计原则" class="headerlink" title="8、 索引的创建与设计原则"></a>8、 索引的创建与设计原则</h1><h2 id="2、索引的必要使用场景"><a href="#2、索引的必要使用场景" class="headerlink" title="2、索引的必要使用场景"></a>2、索引的必要使用场景</h2><h3 id="1-字段的数值有唯一性的限制"><a href="#1-字段的数值有唯一性的限制" class="headerlink" title="1). 字段的数值有唯一性的限制"></a>1). 字段的数值有唯一性的限制</h3><p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。</p><p>说明：唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。</p><h3 id="2-频繁作为-WHERE-查询条件的字段"><a href="#2-频繁作为-WHERE-查询条件的字段" class="headerlink" title="2). 频繁作为 WHERE 查询条件的字段"></a>2). 频繁作为 WHERE 查询条件的字段</h3><p>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p><p>比如查询 <code>student_id =144324</code>的时候</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> course_id ,class_id, `name`,create_time,student_id</span><br><span class="line"><span class="keyword">FROM</span> student_info </span><br><span class="line"><span class="keyword">WHERE</span> student_id <span class="operator">=</span><span class="number">144324</span></span><br></pre></td></tr></table></figure><ul><li><p>在student_id不加索引的情况下，<strong>100w</strong>条数据，耗时为<strong>350ms</strong>左右，即在百毫秒级</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student_info </span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_sid(student_id)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> student_info  #查看是否添加成功</span><br></pre></td></tr></table></figure></li><li><p>在添加索引的情况下，耗时为<strong>22ms</strong>，降了一个数量级，这是很客观的。</p></li></ul><hr><h3 id="3-经常-GROUP-BY-和-ORDER-BY-的列"><a href="#3-经常-GROUP-BY-和-ORDER-BY-的列" class="headerlink" title="3). 经常 GROUP BY 和 ORDER BY 的列"></a>3). 经常 GROUP BY 和 ORDER BY 的列</h3><p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用<code>GROUP BY</code>对数据进行分组查询，或者使用<code>ORDER BY</code>对数据进行排序的时候，就需要对分组或者排序的字段进行索引，从而减少排序的时间。如果待排序的列有多个，那么可以在这些列上建立组合索引。</p><h4 id="1-GROUP-BY"><a href="#1-GROUP-BY" class="headerlink" title="1. GROUP BY"></a>1. GROUP BY</h4><p>eg：在100w条数据中，按照<code>student_id</code>对学生选修课程进行分组，显示不同的<code>student_id</code>和课程数量，显示100个。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id ,<span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num</span><br><span class="line"><span class="keyword">FROM</span> student_info</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> student_id LIMIT <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_sid <span class="keyword">ON</span> student_info</span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> student_info</span><br></pre></td></tr></table></figure><ul><li>在不加索引的情况下，耗时850毫秒。</li><li>在加索引的情况下（这里使用的是2）当中的<code>idx_sid</code>索引），耗时21毫秒。</li></ul><h4 id="2-ORDER-BY"><a href="#2-ORDER-BY" class="headerlink" title="2. ORDER BY"></a>2. ORDER BY</h4><p>ORDER BY单独使用的情况与GROUP BY差不多</p><h4 id="3-ORDER-BY和GROUP-BY同时使用的情况"><a href="#3-ORDER-BY和GROUP-BY同时使用的情况" class="headerlink" title="3. ORDER BY和GROUP BY同时使用的情况"></a>3. ORDER BY和GROUP BY同时使用的情况</h4><p>&#x3D;&#x3D;由于<code>GROUP BY</code>先执行，且GROUP BY为先排序再分组，所以主要耗时就集中在GROUP BY上。&#x3D;&#x3D;</p><p><strong>使用以下三种情况来观察不同索引状况下，sql执行的速度差异</strong></p><ul><li>三种情况：</li></ul><p>​        ①. <code>student_id</code>和<code>create_time</code>分别建立索引</p><p>​        ②. <code>student_id</code>和<code>create_time</code>建立联合索引，且student_id在前</p><p>​        ③. <code>student_id</code>和<code>create_time</code>建立联合索引，且create_time在前</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id,<span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="keyword">AS</span>num</span><br><span class="line"><span class="keyword">FROM</span>student_info</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>student_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>create_time <span class="keyword">desc</span></span><br><span class="line">LIMIT <span class="number">100</span></span><br></pre></td></tr></table></figure><p>不加除主键索引以外的其他索引的情况下，耗时约&#x3D;&#x3D;0.8~1s&#x3D;&#x3D;</p><ul><li>两种版本：</li></ul><p>​        ①. MySQL 5.7.5及以上功能依赖检测功能</p><p>​        ②. MySQL 5.7.5以下无依赖检测功能</p><p>执行上方代码后MySQL 5.7.5及以上会报错</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sql_mode<span class="operator">=</span>only_full_group_by #出现问题</span><br></pre></td></tr></table></figure><p>MySQL 5.7.5及以上由于<code>sql_mode=only_full_group_by</code>是默认开启依赖检测功能，所以<code>HAVING</code>条件或<code>ORDER BY</code>列表的查询引用在<code>GROUP BY</code>子句中。<br>    <strong>简单来说就是：输出的结果是叫target list，就是select后面跟着的字段，还有一个地方group by column，就是group by后面跟着的字段。由于开启ONLY_FULL_GROUP_BY的设置，如果一个字段没有在target list和group by字段中同时出现，或者是聚合函数的值的话，那么这条sql查询是被mysql认为非法的，会报错误。</strong></p><p>但是如果同时GROUP BY student_id，create_time 这两个字段，就失去了本例的作用。所以需要MySQL 5.7.5及以上的需要关闭依赖检测功能</p><p>具体解析链接&#x3D;&#x3D;&#x3D;&#x3D;》<a href="https://shimo.im/docs/VMAPVynD0nU1vbqg">文档——石墨</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@global</span>.sql_mode #查看sql_mode详细</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@global</span>.sql_mode <span class="operator">=</span><span class="string">&#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#x27;</span>; #去掉ONLY_FULL_GROUP_BY，重新设置值，对于新建的数据库有效 <span class="number">8.0</span>中还要去掉NO_AUTO_CREATE_USER</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> sql_mode<span class="operator">=</span><span class="string">&#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#x27;</span>;  #对于已存在的数据库，则需要在对应的数据下执行</span><br></pre></td></tr></table></figure><p>继续测试</p><ol><li><p>添加单列<code>student_id</code>索引和<code>create_time</code>索引</p><p>​    5.7中：</p><p>耗时6s左右，添加索引就是将这些时间提前消耗掉，让客户查询的时候减少查询时间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student_info</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_sid(student_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student_info</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_cre_time(create_time <span class="keyword">DESC</span>);</span><br></pre></td></tr></table></figure><p><strong>这里 EXPLAIN 后会发现只使用了student_id 的索引idx_sid（单列索引的情况，只使用语句执行过程第一个索引）所以这里只使用了索引idx_sid，而idx_cre_time压根没用到。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> student_info</span><br><span class="line"></span><br><span class="line">EXPLAIN </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> student_id,<span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="keyword">AS</span>num</span><br><span class="line"><span class="keyword">FROM</span>student_info</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>student_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>create_time <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>各自单列索引的情况下，耗时大约1.5s（上面不加索引的情况下耗时1s）</p><p>​    8.0中</p><p>&#x3D;&#x3D;todo 不明原因，未得到解决，上述方式在5.7中大约需要1.5s左右，而在8.0中需要几分钟的时间。&#x3D;&#x3D;</p></li><li><p>联合索引的情况① ：</p><p>先删除除主键外其他的单列索引</p><p><strong>idx_sid_cre_time(student_id,create_time)，student_id在前</strong></p><p>​    5.7：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student_info</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_sid_cre_time(student_id,create_time);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> student_info;</span><br><span class="line"></span><br><span class="line">EXPLAIN </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> student_id,<span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="keyword">AS</span>num</span><br><span class="line"><span class="keyword">FROM</span>student_info</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>student_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>create_time <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blogimg.ytte.top//img-jixiang/20220306131117.png"></p><p>耗时约&#x3D;&#x3D;300ms&#x3D;&#x3D;左右（未加索引1s左右，单列索引1.5s左右）</p><p>8.0：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX  idx_sid <span class="keyword">ON</span> student_info ;</span><br><span class="line"><span class="keyword">DROP</span> INDEX  idx_cre_time <span class="keyword">ON</span> student_info;</span><br><span class="line"><span class="keyword">DROP</span> INDEX  idx_sid_cre_time <span class="keyword">ON</span> student_info;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student_info</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_sid_cre_time(student_id,create_time <span class="keyword">DESC</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> student_info;</span><br><span class="line"></span><br><span class="line">EXPLAIN </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> student_id,<span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="keyword">AS</span>num</span><br><span class="line"><span class="keyword">FROM</span>student_info</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>student_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>create_time <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">100</span>;</span><br></pre></td></tr></table></figure><ul><li><p>索引不加<code>DESC</code>时，耗时约&#x3D;&#x3D;800ms&#x3D;&#x3D;左右（不加索引1s左右，单列索引几分钟）</p></li><li><p>索引加<code>DESC</code>时，耗时约&#x3D;&#x3D;300ms&#x3D;&#x3D;左右（不加索引1s左右，单列索引几分钟）</p></li></ul></li><li><p>联合索引的情况② ：</p><p><strong>idx_cre_sid_time(create_time,student_id)，create_time在前</strong></p><p>在语句执行中，先进行group by 所以此时如果存在<code>idx_sid(student_id)</code>的话，会优先使用group by student_id的student_id索引（idx_sid），这样就变成了使用单列索引，联合索引idx_sid_cre_time就不起作用了。</p><p>如果不存在idx_sid，只有联合索引idx_cre_sid_time：</p><p>​    5.7：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX  idx_sid <span class="keyword">ON</span> student_info ;</span><br><span class="line"><span class="keyword">DROP</span> INDEX  idx_cre_time <span class="keyword">ON</span> student_info;</span><br><span class="line"><span class="keyword">DROP</span> INDEX  idx_sid_cre_time <span class="keyword">ON</span> student_info;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student_info</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_cre_sid_time(create_time,student_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> student_id,<span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="keyword">AS</span>num</span><br><span class="line"><span class="keyword">FROM</span>student_info</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>student_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>create_time <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>耗时约&#x3D;&#x3D;800ms左右&#x3D;&#x3D; （未加索引1s左右，单列索引1.5s左右，idx_sid_cre_time索引耗时约300ms）</p><p>​    8.0 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX  idx_sid <span class="keyword">ON</span> student_info ;</span><br><span class="line"><span class="keyword">DROP</span> INDEX  idx_cre_time <span class="keyword">ON</span> student_info;</span><br><span class="line"><span class="keyword">DROP</span> INDEX  idx_sid_cre_time <span class="keyword">ON</span> student_info;</span><br><span class="line"><span class="keyword">DROP</span> INDEX  idx_cre_sid_time <span class="keyword">ON</span> student_info;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student_info</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_cre_sid_time(create_time <span class="keyword">DESC</span>,student_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> student_id,<span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="keyword">AS</span>num</span><br><span class="line"><span class="keyword">FROM</span>student_info</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>student_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>create_time <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">100</span>;</span><br></pre></td></tr></table></figure><ul><li><p>索引不加<code>DESC</code>时，耗时约&#x3D;&#x3D;1s&#x3D;&#x3D;左右（不加索引1s左右，单列索引几分钟，idx_sid_cre_time索引800ms左右）</p></li><li><p>索引加<code>DESC</code>时，耗时约&#x3D;&#x3D;1s&#x3D;&#x3D;左右（不加索引1s左右，单列索引几分钟，idx_sid_cre_time索引300ms左右）</p></li></ul></li></ol><h3 id="4-UPDATE、DELETE-的-WHERE-条件列"><a href="#4-UPDATE、DELETE-的-WHERE-条件列" class="headerlink" title="4). UPDATE、DELETE 的 WHERE 条件列"></a>4). UPDATE、DELETE 的 WHERE 条件列</h3><p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。</p><p>原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</strong></p><h3 id="5-DISTINCT-字段需要创建索引"><a href="#5-DISTINCT-字段需要创建索引" class="headerlink" title="5). DISTINCT 字段需要创建索引"></a>5). DISTINCT 字段需要创建索引</h3><p>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。</p><p>比如，我们想要查询课程表中不同的 student_id 都有哪些，如果我们没有对 student_id 创建索引，执行</p><p>SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(student_id) <span class="keyword">FROM</span> `student_info`;</span><br></pre></td></tr></table></figure><p>运行结果（600637 条记录，运行时间 0.683s ）：</p><p>如果我们对 student_id 创建索引，再执行 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(student_id) <span class="keyword">FROM</span> `student_info`;</span><br></pre></td></tr></table></figure><p>运行结果（600637 条记录，运行时间 0.010s ）：</p><p>SQL 查询效率有了提升，同时显示出来的 student_id 还是按照 递增的顺序 进行展示的。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。</p><h3 id="6-多表-JOIN-连接操作时，创建索引注意事项"><a href="#6-多表-JOIN-连接操作时，创建索引注意事项" class="headerlink" title="6). 多表 JOIN 连接操作时，创建索引注意事项"></a>6). 多表 JOIN 连接操作时，创建索引注意事项</h3><p>首先， &#x3D;&#x3D;连接表的数量尽量不要超过 3 张&#x3D;&#x3D;，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。</p><p>其次， 对 WHERE 条件创建索引 ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</p><p>最后，&#x3D;&#x3D;类似字符串和int比较时，会存在隐式转换，即使用了函数，一旦使用了函数就会让索引失效。 对用于连接的字段创建索引 ，并且该字段在多张表中的 类型必须一致 。&#x3D;&#x3D;比如 course_id 在 student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。</p><p>举个例子，如果我们只对 student_id 创建索引，执行 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> course_id, name, student_info.student_id, course_name </span><br><span class="line"><span class="keyword">FROM</span> student_info <span class="keyword">JOIN</span> course </span><br><span class="line"><span class="keyword">ON</span> student_info.course_id <span class="operator">=</span> course.course_id </span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;462eed7ac6e791292a79&#x27;</span>;</span><br></pre></td></tr></table></figure><p>运行结果（1 条数据，运行时间 0.189s ）：</p><p>这里我们对 name 创建索引，再执行上面的 SQL 语句，运行时间为 0.002s 。 </p><h3 id="7-使用列的类型小的创建索引"><a href="#7-使用列的类型小的创建索引" class="headerlink" title="7). 使用列的类型小的创建索引"></a>7). 使用列的类型小的创建索引</h3><p><img src="https://blogimg.ytte.top//img-jixiang/20220306160740.png"></p><h3 id="8-使用字符串前缀创建索引"><a href="#8-使用字符串前缀创建索引" class="headerlink" title="8). 使用字符串前缀创建索引"></a>8). 使用字符串前缀创建索引</h3><p><img src="https://blogimg.ytte.top//img-jixiang/20220306161326.png"></p><p>创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> shop(address <span class="type">varchar</span>(<span class="number">120</span>) <span class="keyword">not</span> <span class="keyword">null</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> shop <span class="keyword">add</span> index(address(<span class="number">12</span>)); </span><br></pre></td></tr></table></figure><p>问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字</p><p>段的散列度(选择性)会降低。<strong>怎么计算不同的长度的选择性呢？</strong></p><p>先看一下字段在全部数据中的选择度：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> address) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> shop;</span><br></pre></td></tr></table></figure><p>通过不同长度去计算，与全表的选择性对比：</p><p>公式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(列名, 索引长度))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>)</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address,<span class="number">10</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub10, <span class="comment">-- 截取前10个字符的选择度 </span></span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address,<span class="number">15</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub11, <span class="comment">-- 截取前15个字符的选择度 </span></span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address,<span class="number">20</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub12, <span class="comment">-- 截取前20个字符的选择度 </span></span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address,<span class="number">25</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub13 <span class="comment">-- 截取前25个字符的选择度</span></span><br><span class="line"><span class="keyword">from</span> shop;</span><br></pre></td></tr></table></figure><p><strong>引申另一个问题：索引列前缀对排序的影响</strong></p><p><strong>拓展：Alibaba《Java开发手册》</strong></p><p>&#x3D;&#x3D;在 varchar 字段上建立索引时，必须指定索引长度，根据实际文本区分度决定索引长度。&#x3D;&#x3D;</p><p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会 高达 90% 以上 ，可以使用</p><p><code> count(distinct left(列名, 索引长度))/count(*)</code>的区分度来确定。</p><h3 id="9-区分度高-散列性高-的列适合作为索引"><a href="#9-区分度高-散列性高-的列适合作为索引" class="headerlink" title="9). 区分度高(散列性高)的列适合作为索引"></a>9). 区分度高(散列性高)的列适合作为索引</h3><p><img src="https://blogimg.ytte.top//img-jixiang/20220306161828.png"></p><h3 id="10-使用最频繁的列放到联合索引的左侧"><a href="#10-使用最频繁的列放到联合索引的左侧" class="headerlink" title="10). 使用最频繁的列放到联合索引的左侧"></a>10). 使用最频繁的列放到联合索引的左侧</h3><h3 id="11-在多个字段都要创建索引的情况下，联合索引优于单值索引"><a href="#11-在多个字段都要创建索引的情况下，联合索引优于单值索引" class="headerlink" title="11). 在多个字段都要创建索引的情况下，联合索引优于单值索引"></a>11). 在多个字段都要创建索引的情况下，联合索引优于单值索引</h3><h2 id="3-限制索引的数目"><a href="#3-限制索引的数目" class="headerlink" title="3. 限制索引的数目"></a>3. 限制索引的数目</h2><p><img src="https://blogimg.ytte.top//img-jixiang/20220306162540.png"></p><h2 id="4-哪些情况不适合创建索引"><a href="#4-哪些情况不适合创建索引" class="headerlink" title="4. 哪些情况不适合创建索引"></a>4. <strong>哪些情况不适合创建索引</strong></h2><ol><li>WHERE条件（包括GROUP BY、ORDER BY)里用不到的字段不需要创建索引</li><li>数据量小的表最好不要使用索引</li><li>有大量重复数据的列上不要建立索引<ul><li>比如性别。</li></ul></li><li>避免对经常更新的表创建过多的索引</li><li>不建议用无序的值作为索引<ul><li>例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。</li></ul></li><li>删除不再使用或者很少使用的索引</li><li>不要定义冗余或重复的索引</li></ol><h1 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h1><ol><li>我们进行内联查询前，最好能限制连的表大小的条件都先用上了，同时尽量让条件查询和分组执行的表尽量小&#x3D;&#x3D;&#x3D;&#x3D;》<a href="https://blog.csdn.net/Tim_phper/article/details/78344444">CSDN博客_mysql联表查询优化① </a></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;MySQL&quot;&gt;&lt;a href=&quot;#MySQL&quot; class=&quot;headerlink&quot; title=&quot;MySQL&quot;&gt;&lt;/a&gt;MySQL&lt;/h1&gt;&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="MySQL" scheme="https://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>JVM上篇</title>
    <link href="https://example.com/2022/03/19/JVM%E4%B8%8A%E7%AF%87/"/>
    <id>https://example.com/2022/03/19/JVM%E4%B8%8A%E7%AF%87/</id>
    <published>2022-03-19T05:20:02.937Z</published>
    <updated>2022-03-19T06:58:22.647Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="JVM上篇"><a href="#JVM上篇" class="headerlink" title="JVM上篇"></a>JVM上篇</h1><h1 id="JVM与Java体系结构"><a href="#JVM与Java体系结构" class="headerlink" title="JVM与Java体系结构"></a>JVM与Java体系结构</h1><h2 id="1-Java虚拟机整体架构祥图"><a href="#1-Java虚拟机整体架构祥图" class="headerlink" title="1. Java虚拟机整体架构祥图"></a>1. Java虚拟机整体架构祥图</h2><p><img src="https://blogimg.ytte.top//img-jixiang/20220307170759.png"></p><h2 id="2-Java代码执行过程详图"><a href="#2-Java代码执行过程详图" class="headerlink" title="2.Java代码执行过程详图"></a>2.Java代码执行过程详图</h2><p><img src="https://blogimg.ytte.top//img-jixiang/20220307170826.png"></p><h2 id="3-JVM的架构模型"><a href="#3-JVM的架构模型" class="headerlink" title="3. JVM的架构模型"></a>3. JVM的架构模型</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;JVM上篇&quot;&gt;&lt;a href=&quot;#JVM上篇&quot; class=&quot;headerlink&quot; title=&quot;JVM上篇&quot;&gt;&lt;/a&gt;JVM上篇&lt;/h1&gt;&lt;h1 id=&quot;JVM与Java体系结构&quot;&gt;&lt;a href=&quot;#JVM与</summary>
      
    
    
    
    <category term="JVM" scheme="https://example.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Filter/ Lstener/ Servlet/四大域对象</title>
    <link href="https://example.com/2022/03/19/Filter%E3%80%81Listener%E3%80%81Servlet%E3%80%81%E5%9B%9B%E5%A4%A7%E5%9F%9F%E5%AF%B9%E8%B1%A1/"/>
    <id>https://example.com/2022/03/19/Filter%E3%80%81Listener%E3%80%81Servlet%E3%80%81%E5%9B%9B%E5%A4%A7%E5%9F%9F%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-03-19T05:20:02.934Z</published>
    <updated>2022-03-19T06:59:02.720Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h1><p><a href="https://blog.csdn.net/yuzhiqiang_1993/article/details/81288912?ops_request_misc=%7B%22request_id%22:%22164725630116781683948193%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=164725630116781683948193&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-81288912.142%5Ev2%5Epc_search_result_cache,143%5Ev4%5Eregister&utm_term=Filter&spm=1018.2226.3001.4187">Filter-CSDN博客_java过滤器</a></p><h1 id="Lstener"><a href="#Lstener" class="headerlink" title="Lstener"></a>Lstener</h1><p><a href="https://www.jianshu.com/p/313830fe6707">Filter与Listener - 简书 (jianshu.com)</a></p><p><a href="https://blog.csdn.net/qq_39240270/article/details/86383107?ops_request_misc=%7B%22request_id%22:%22164726004316780264077068%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=164726004316780264077068&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-86383107.142%5Ev2%5Epc_search_result_cache,143%5Ev4%5Eregister&utm_term=listener&spm=1018.2226.3001.4187">Listener(监听器)的简单介绍_LrvingTc的博客-CSDN博客_listener</a></p><h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p><a href="https://blog.csdn.net/qq_19782019/article/details/80292110?ops_request_misc=%7B%22request_id%22:%22164731495216780255258032%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164731495216780255258032&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-80292110.142%5Ev2%5Epc_search_result_cache,143%5Ev4%5Eregister&utm_term=Servlet&spm=1018.2226.3001.4187">JavaWeb——Servlet（全网最详细教程包括Servlet源码分析）_扬俊的小屋-CSDN博客_servlet</a></p><h1 id="四大域对象"><a href="#四大域对象" class="headerlink" title="四大域对象"></a>四大域对象</h1><p><a href="https://www.jianshu.com/p/6c02951267d8">JavaWeb四大域对象 - 简书 (jianshu.com)</a></p><p><a href="https://blog.csdn.net/shangrila_kun/article/details/89339864">JAVA中的四大域对象总结_kun blog-CSDN博客_域对象</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;Filter&quot;&gt;&lt;a href=&quot;#Filter&quot; class=&quot;headerlink&quot; title=&quot;Filter&quot;&gt;&lt;/a&gt;Filter&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.ne</summary>
      
    
    
    
    <category term="java" scheme="https://example.com/categories/java/"/>
    
    
    <category term="基础" scheme="https://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>一级域名</title>
    <link href="https://example.com/2022/03/19/%E4%B8%80%E7%BA%A7%E5%9F%9F%E5%90%8D/"/>
    <id>https://example.com/2022/03/19/%E4%B8%80%E7%BA%A7%E5%9F%9F%E5%90%8D/</id>
    <published>2022-03-19T05:20:02.928Z</published>
    <updated>2022-03-19T06:00:25.423Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="一级域名"><a href="#一级域名" class="headerlink" title="一级域名"></a>一级域名</h1><h1 id="1-购买域名"><a href="#1-购买域名" class="headerlink" title="1. 购买域名"></a>1. 购买域名</h1><ul><li>地址：<a href="https://wanwang.aliyun.com/domain/tld#.work">域名_域名查询_域名注册_.com_.cn-阿里云 (aliyun.com)</a></li></ul><p>任何服务，都可以不买，只购买域名使用权</p><p><img src="https://blogimg.ytte.top//img-jixiang/20220304224052.png"></p><ul><li><p>选择个人</p></li><li><p>选择个人信息</p></li></ul><p><img src="https://blogimg.ytte.top//img-jixiang/image-20220304224215230.png" alt="image-20220304224215230"></p><ul><li><p>未实名认证的，进行阿里云<a href="https://help.aliyun.com/document_detail/48263.html?spm=5176.22414175.sslink.5.62de60d4kx33cX">个人实名认证 (aliyun.com)</a></p></li><li><p>选择已阅读，购买</p></li></ul><h1 id="2-等待审核"><a href="#2-等待审核" class="headerlink" title="2. 等待审核"></a>2. 等待审核</h1><p>进入控制台，点击域名列表可以看到，域名正在审核</p><p><img src="https://blogimg.ytte.top//img-jixiang/20220304225051.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;一级域名&quot;&gt;&lt;a href=&quot;#一级域名&quot; class=&quot;headerlink&quot; title=&quot;一级域名&quot;&gt;&lt;/a&gt;一级域名&lt;/h1&gt;&lt;h1 id=&quot;1-购买域名&quot;&gt;&lt;a href=&quot;#1-购买域名&quot; class=</summary>
      
    
    
    
    <category term="服务器" scheme="https://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="域名" scheme="https://example.com/tags/%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>typora</title>
    <link href="https://example.com/2022/03/19/%E4%BD%BF%E7%94%A8typora%E5%86%99%E6%96%87%E6%A1%A3%E4%BC%A0%E5%9B%BE%E7%89%87%EF%BC%8C%E5%86%8D%E4%B8%8A%E4%BC%A0%E7%9F%B3%E5%A2%A8%E7%AD%89%E7%BD%91%E7%AB%99%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://example.com/2022/03/19/%E4%BD%BF%E7%94%A8typora%E5%86%99%E6%96%87%E6%A1%A3%E4%BC%A0%E5%9B%BE%E7%89%87%EF%BC%8C%E5%86%8D%E4%B8%8A%E4%BC%A0%E7%9F%B3%E5%A2%A8%E7%AD%89%E7%BD%91%E7%AB%99%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2022-03-19T05:20:02.925Z</published>
    <updated>2022-03-19T06:00:16.520Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="使用typora写文档传图片，再上传石墨等网站的好方法"><a href="#使用typora写文档传图片，再上传石墨等网站的好方法" class="headerlink" title="使用typora写文档传图片，再上传石墨等网站的好方法"></a>使用typora写文档传图片，再上传石墨等网站的好方法</h1><h2 id="1-typora下载"><a href="#1-typora下载" class="headerlink" title="1. typora下载"></a>1. typora下载</h2><p>typora开始收费，我们可以使用不收费的老版本 <a href="http://static.ytte.top/%E8%BD%AF%E4%BB%B6/typora-update-x64-1117.exe">下载链接</a> </p><h2 id="2-typora图床"><a href="#2-typora图床" class="headerlink" title="2. typora图床"></a>2. typora图床</h2><p>picgotypora不像word，word可以直接将上传的图片保存在文件当中，而typora不行。但是typora支持picgo插件的使用，所以，我们下在<a href="https://molunerfinn.com/PicGo">picgo 下载链接</a> </p><h2 id="3-七牛云和picgo的使用，二级域名（如果不想弄直接第4步骤）"><a href="#3-七牛云和picgo的使用，二级域名（如果不想弄直接第4步骤）" class="headerlink" title="3. 七牛云和picgo的使用，二级域名（如果不想弄直接第4步骤）"></a>3. 七牛云和picgo的使用，二级域名（<strong>如果不想弄直接第4步骤</strong>）</h2><p>注册七牛云 ，并开通对象存储  <a href="https://zhuanlan.zhihu.com/p/141610018">picgo使用七牛云图床 - 知乎 </a>。为七牛云配置二级域名（前提是有了一级域名）：<a href="https://shimo.im/docs/gXqmeE0KwQhOgXqo">二级域名-石墨</a> </p><h2 id="4-picgo-配置："><a href="#4-picgo-配置：" class="headerlink" title="4. picgo 配置："></a>4. picgo 配置：</h2><p>进入picgo，点击左侧的图床设置，选择七牛图床。按下图所示填写配置，SecretKey向    j j  索取。</p><blockquote><p>SbOIcbA56xQGcpZyyLDtuARvi3COHhlBxa-IZxDi</p><p>ytte-picgo</p><p><a href="https://blogimg.ytte.top/">https://blogimg.ytte.top/</a></p><p>z2 </p><p>img-sunsifan&#x2F;或者是img-wuhao</p></blockquote><p>伍昊：</p><p><img src="https://blogimg.ytte.top//img-jixiang/20220304214009.png"></p><p>孙思凡：</p><p>将最后 一项，指定存储路径更改为：img-sunsifan。</p><h2 id="5-typora设置"><a href="#5-typora设置" class="headerlink" title="5.  typora设置"></a>5.  typora设置</h2><ul><li><p>打开typora后，</p></li><li><p>点击左上角文件，</p></li><li><p>点击偏好设置，</p></li><li><p>点击图像，</p></li><li><p>如图进行配置，</p></li></ul><p><img src="https://blogimg.ytte.top//img-jixiang/20220304221630.png"></p><ul><li>成功就会出现如图信息，</li></ul><p><img src="https://blogimg.ytte.top//img-jixiang/20220304221645.png"></p><p>&#x3D;&#x3D;<strong>大功告成</strong>&#x3D;&#x3D;</p><h2 id="6-picgo的使用"><a href="#6-picgo的使用" class="headerlink" title="6. picgo的使用"></a>6. picgo的使用</h2><p>使用截图软件截图，打开picgo点记左侧的上传区，点击剪切板图片上传，上传成功后自动将图片地址返回到剪切板当中。</p><blockquote><p>注意：如果直接截图后直接粘贴到typora文中，使用的是<img/>标签，在有的编辑器不能正常识别（比如石墨），所以最好先按上面方法。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;



&lt;h1 id=&quot;使用typora写文档传图片，再上传石墨等网站的好方法&quot;&gt;&lt;a href=&quot;#使用typora写文档传图片，再上传石墨等网站的好方法&quot; class=&quot;headerlink&quot; title=&quot;使用typora写文档</summary>
      
    
    
    
    <category term="杂项" scheme="https://example.com/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="typora" scheme="https://example.com/tags/typora/"/>
    
  </entry>
  
  <entry>
    <title>谷粒商城步骤笔记</title>
    <link href="https://example.com/2022/03/19/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E6%AD%A5%E9%AA%A4%E7%AC%94%E8%AE%B0/"/>
    <id>https://example.com/2022/03/19/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E6%AD%A5%E9%AA%A4%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-19T05:20:02.922Z</published>
    <updated>2022-03-19T05:54:28.627Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="谷粒商城步骤笔记"><a href="#谷粒商城步骤笔记" class="headerlink" title="谷粒商城步骤笔记"></a>谷粒商城步骤笔记</h1><h1 id="使用人人代码生成器"><a href="#使用人人代码生成器" class="headerlink" title="使用人人代码生成器"></a>使用人人代码生成器</h1><p>视频&#x3D;&#x3D;&#x3D;&#x3D;》<a href="https://www.bilibili.com/video/BV1np4y1C7Yf?p=17&spm_id_from=pageDriver">谷粒商城——p17</a></p><ol><li><p>clone人人代码生成器</p></li><li><p>放进项目中加入模块</p></li><li><p>在application.yml修改数据库相关信息</p></li><li><p>在generator.properties中修改参数</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mainPath=com.atguigu</span></span><br><span class="line"><span class="comment">#包名</span></span><br><span class="line"><span class="string">package=com.atguigu.gulimall</span></span><br><span class="line"><span class="string">moduleName=product</span></span><br><span class="line"><span class="comment">#作者</span></span><br><span class="line"><span class="string">author=yttejx</span></span><br><span class="line"><span class="comment">#Email</span></span><br><span class="line"><span class="string">email=1026190684@qq.com</span></span><br><span class="line"><span class="comment">#表前缀(类名不会包含表前缀)</span></span><br><span class="line"><span class="string">tablePrefix=pms_</span></span><br></pre></td></tr></table></figure></li><li><p>更改renren-generator的resources的template的Controller模板中@RequiresPermissions注解和导包注释掉，以后再导入使用。</p></li><li><p>启动renren-generator的Application。网页访问localhost:80，点击显示全部表格，全选表格，点击生成代码。</p></li><li><p>将生成的代码中main包复制粘贴到product项目下。</p></li><li><p>新建模块（maven）取名，gulimall_common（项目的公共资源全部放在这里）</p></li><li><p>查看product项目中报错信息。将相应的pom 和类（renren自己创建的工具类）加入到common项目中</p><p>从renren-faster中导入</p><ul><li><p>包：</p><ul><li>exception </li><li>utils<ul><li>Constant</li><li>PageUtils</li><li>Query</li><li>R</li><li>validator</li><li>xss<ul><li>去掉XssFilter和XssHttpServletRequestWrapper，是防跨站脚本攻击的，以后用springsecurity来实现。</li><li>这里需要导包Servlet，同时设置scope 为provided，因为tomcat内有Servlet</li></ul></li></ul></li></ul></li><li><p>pom：</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mybatis.plus.boot.starter.version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">mybatis.plus.boot.starter.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">lombok.version</span>&gt;</span>1.18.22<span class="tag">&lt;/<span class="name">lombok.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commons.lang.version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">commons.lang.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">httpcore.version</span>&gt;</span>4.4.15<span class="tag">&lt;/<span class="name">httpcore.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shiro.version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">shiro.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commons.io.version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">commons.io.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql.connector.version</span>&gt;</span>8.0.28<span class="tag">&lt;/<span class="name">mysql.connector.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.plus.boot.starter.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lombok.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;commons.lang.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpcore --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--java 发送http请求--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpcore<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;httpcore.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;commons.io.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;shiro.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;shiro.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.connector.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- tomcat内有Servlet--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>product的UndoLogEntity的rollbackInfo属性，数据库中使用的是Longblob，实体类中使用byte[]。</p></li></ol><h1 id="配置-amp-测试服务的crud功能"><a href="#配置-amp-测试服务的crud功能" class="headerlink" title="配置&amp;测试服务的crud功能"></a>配置&amp;测试服务的crud功能</h1><p>视频&#x3D;&#x3D;&#x3D;&#x3D;》<a href="https://www.bilibili.com/video/BV1np4y1C7Yf?p=18&spm_id_from=pageDriver">谷粒商城——p18</a></p><ol><li><p>每个项目都需要crud，所以在common中导入mysql驱动</p></li><li><p>配置数据源</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">as123</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3380/gulimall_pms?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure></li><li><p>配置mybatis-plus</p><ul><li>使用MapperScan</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;com.atguigu.gulimall.product.dao&quot;)</span></span><br></pre></td></tr></table></figure><ul><li><p>告诉mybatis-plus，sql映射文件位置</p><p>使用自增主键（以后数据量大了在使用其他主键策略）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath*:/mapper/**/*.xml</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br></pre></td></tr></table></figure></li><li><p>crud测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">BrandEntity</span> <span class="variable">brandEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BrandEntity</span>();</span><br><span class="line">        brandEntity.setName(<span class="string">&quot;华为&quot;</span>);</span><br><span class="line"></span><br><span class="line">        brandService.save(brandEntity);</span><br><span class="line">        System.out.println(<span class="string">&quot;保存成功----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        brandEntity.setBrandId(<span class="number">1L</span>);</span><br><span class="line">        brandEntity.setDescript(<span class="string">&quot;华为手机&quot;</span>);</span><br><span class="line">        brandService.updateById(brandEntity);</span><br><span class="line">        System.out.println(<span class="string">&quot;更新成功---------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;BrandEntity&gt; list = brandService.list(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;BrandEntity&gt;().eq(BrandEntity::getBrandId, <span class="string">&quot;1&quot;</span>));</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;查询成功---------&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="逆向工程生成所有代码"><a href="#逆向工程生成所有代码" class="headerlink" title="逆向工程生成所有代码"></a>逆向工程生成所有代码</h1><p>   视频&#x3D;&#x3D;&#x3D;&#x3D;》<a href="https://www.bilibili.com/video/BV1np4y1C7Yf?p=19&spm_id_from=pageDriver">p19</a> </p><h1 id="分"><a href="#分" class="headerlink" title="分"></a>分</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;谷粒商城步骤笔记&quot;&gt;&lt;a href=&quot;#谷粒商城步骤笔记&quot; class=&quot;headerlink&quot; title=&quot;谷粒商城步骤笔记&quot;&gt;&lt;/a&gt;谷粒商城步骤笔记&lt;/h1&gt;&lt;h1 id=&quot;使用人人代码生成器&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="项目" scheme="https://example.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="谷粒商城" scheme="https://example.com/tags/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/"/>
    
  </entry>
  
  <entry>
    <title>二级域名</title>
    <link href="https://example.com/2022/03/19/%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D/"/>
    <id>https://example.com/2022/03/19/%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D/</id>
    <published>2022-03-19T05:20:02.916Z</published>
    <updated>2022-03-19T05:59:16.500Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="二级域名"><a href="#二级域名" class="headerlink" title="二级域名"></a>二级域名</h1><p>给七牛云配置阿里云所属顶级域名的二级域名</p><h1 id="1-首先要有一级域名"><a href="#1-首先要有一级域名" class="headerlink" title="1. 首先要有一级域名"></a>1. 首先要有一级域名</h1><p><a href="https://shimo.im/docs/5xkGMvanzofDpz3X">一级域名-石墨</a></p><h1 id="2-配置七牛云"><a href="#2-配置七牛云" class="headerlink" title="2.配置七牛云"></a>2.配置七牛云</h1><p>尽量选择华南地区（便宜）。</p><ul><li>点击域名</li></ul><p><img src="https://gitee.com/mascot-ji/picgo/raw/master/img/20220304233000.png"></p><ul><li>点击域名绑定</li></ul><p><img src="https://gitee.com/mascot-ji/picgo/raw/master/img/20220304233430.png"></p><ul><li>点击创建</li><li>如下图，说明创建成功，</li></ul><p><img src="https://gitee.com/mascot-ji/picgo/raw/master/img/20220304233720.png"></p><ul><li><p>点击复制CNAME（七牛云页面不要关闭）</p><p><img src="https://gitee.com/mascot-ji/picgo/raw/master/img/20220304233752.png"></p></li><li><p>进入阿里云控制台</p></li><li><p>点击域名&#x3D;&gt;点击域名列表</p></li><li><p>点击解析</p><p><img src="https://gitee.com/mascot-ji/picgo/raw/master/img/20220304234005.png"></p></li><li><p>点击添加记录 &#x3D;&gt;点击确认</p><p>这里的主机记录和记录值前缀要一致</p><p><img src="https://blogimg.ytte.top//img-jixiang/image-20220304234228241.png"></p></li><li><p>如果状态显示正常，即可</p><p><img src="https://blogimg.ytte.top//img-jixiang/20220304234459.png"></p></li><li><p>再回到七牛云中，观察是否设置成功</p><p><img src="https://blogimg.ytte.top//img-jixiang/20220304234542.png"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;二级域名&quot;&gt;&lt;a href=&quot;#二级域名&quot; class=&quot;headerlink&quot; title=&quot;二级域名&quot;&gt;&lt;/a&gt;二级域名&lt;/h1&gt;&lt;p&gt;给七牛云配置阿里云所属顶级域名的二级域名&lt;/p&gt;
&lt;h1 id=&quot;1-首先</summary>
      
    
    
    
    <category term="服务器" scheme="https://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="域名" scheme="https://example.com/tags/%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>session，cookie，token</title>
    <link href="https://example.com/2022/03/14/session%EF%BC%8Ccookie%EF%BC%8Ctoken/"/>
    <id>https://example.com/2022/03/14/session%EF%BC%8Ccookie%EF%BC%8Ctoken/</id>
    <published>2022-03-14T10:19:04.000Z</published>
    <updated>2022-03-19T05:16:32.982Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><a href="https://segmentfault.com/a/1190000017831088">彻底弄懂session，cookie，token - SegmentFault 思否</a></p><p><a href="https://www.cnblogs.com/moyand/p/9047978.html">彻底理解cookie，session，token - 墨颜丶 - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000017831088&quot;&gt;彻底弄懂session，cookie，token - SegmentFault 思否&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a h</summary>
      
    
    
    
    <category term="java" scheme="https://example.com/categories/java/"/>
    
    
    <category term="基础" scheme="https://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Consumer、Supplier、Predicate和Function</title>
    <link href="https://example.com/2022/03/14/Consumer%E3%80%81Supplier%E3%80%81Predicate%E5%92%8CFunction/"/>
    <id>https://example.com/2022/03/14/Consumer%E3%80%81Supplier%E3%80%81Predicate%E5%92%8CFunction/</id>
    <published>2022-03-14T01:35:19.000Z</published>
    <updated>2022-03-19T07:04:55.270Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><a href="https://www.cnblogs.com/SIHAIloveYAN/p/11288064.html">Java8之Consumer、Supplier、Predicate和Function攻略 - 公众号好好学java - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/SIHAIloveYAN/p/11288064.html&quot;&gt;Java8之Consumer、Supplier、Predicate和Function攻略 - 公众</summary>
      
    
    
    
    <category term="java" scheme="https://example.com/categories/java/"/>
    
    
    <category term="基础" scheme="https://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper</title>
    <link href="https://example.com/2022/03/14/ZooKeeper/"/>
    <id>https://example.com/2022/03/14/ZooKeeper/</id>
    <published>2022-03-14T01:35:19.000Z</published>
    <updated>2022-03-19T06:02:09.261Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h1><h1 id="非docker-单机（本地）安装配置启动"><a href="#非docker-单机（本地）安装配置启动" class="headerlink" title="非docker 单机（本地）安装配置启动"></a>非docker 单机（本地）安装配置启动</h1><p>视频&#x3D;&#x3D;&#x3D;&#x3D;》<a href="https://www.bilibili.com/video/BV1to4y1C7gw?p=7">_哔哩哔哩_bilibili p7</a></p><ol><li><p>需要jdk环境，并配置环境变量</p><p><a href="https://blog.csdn.net/pdsu161530247/article/details/81582980">linux安装jdk8</a></p></li><li><p>下载ZooKeeper压缩包（<a href="https://archive.apache.org/dist/zookeeper/zookeeper-3.5.7/">Apache Downloads</a>)放在linux下的&#x2F;mnt&#x2F;zookeeper下。</p></li><li><pre><code class="shell">tar -zxvf apache-zookeeper-3.5.7-bin.tar.gz<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 将文件夹改名</span><br><span class="line"></span><br><span class="line">   ```shell</span><br><span class="line">   mv apache-zookeeper-3.5.7-bin/ zookeeper-3.5.7/</span><br></pre></td></tr></table></figure></code></pre></li><li><p>更改conf下 的zoo-sample.cfg为<code>zoo.cfg</code></p></li><li><p>更改zoo.cfg中</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dataDir</span>=<span class="string">/mnt/zookeeper/zookeeper-3.5.7/data</span></span><br><span class="line"><span class="attr">dataLogDir</span>=<span class="string">/mnt/zookeeper/zookeeper-3.5.7/dataLog</span></span><br></pre></td></tr></table></figure></li><li><p><strong>启动服务端：</strong></p><p><strong>注意：</strong>需要在&#x2F;mnt&#x2F;zookeeper&#x2F;zookeeper-3.5.7&#x2F;目录下使用启动命令<code>bin/zkServer.sh start</code> <strong>不能</strong>再&#x2F;mnt&#x2F;zookeeper&#x2F;zookeeper-3.5.7&#x2F;bin&#x2F;目录下使用zkServer.sh start</p></li><li><p>使用jps -l 查看是否启动了zookeeper 的java进程。</p></li><li><p><strong>启动客户端：</strong> <code>bin/zkCli.sh</code></p></li><li><ul><li><p><code>ls /</code>查看节点  </p></li><li><p><code>quit</code>退出客户端 </p></li><li><p><code>bin/zkServer.sh status</code>查看zookeeper的状态（standalone单机模式）</p></li><li><p><code>bin/zkServer.sh stop</code> 停止服务器端</p></li></ul></li></ol><h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><h1 id="配置参数解读"><a href="#配置参数解读" class="headerlink" title="配置参数解读"></a>配置参数解读</h1><p>视频&#x3D;&#x3D;&#x3D;&#x3D;》<a href="https://www.bilibili.com/video/BV1to4y1C7gw?p=8&spm_id_from=pageDriver">p8</a></p><ol><li><p>tickTime&#x3D;2000——通信的心跳时间</p><p>ZooKeeper服务器与客户端之间通信频率，每2000ms发送一次。</p><p><img src="https://blogimg.ytte.top//img-jixiang/20220318171542.png"></p></li><li><p>initLimit&#x3D;10——LF初始通信时限</p></li></ol><p>   Leader与Follower初始连接是</p><p>3. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;ZooKeeper&quot;&gt;&lt;a href=&quot;#ZooKeeper&quot; class=&quot;headerlink&quot; title=&quot;ZooKeeper&quot;&gt;&lt;/a&gt;ZooKeeper&lt;/h1&gt;&lt;h1 id=&quot;非docker-单机（本</summary>
      
    
    
    
    <category term="ZooKeeper" scheme="https://example.com/categories/ZooKeeper/"/>
    
    
    <category term="ZooKeeper" scheme="https://example.com/tags/ZooKeeper/"/>
    
  </entry>
  
</feed>

{"meta":{"title":"YTTE","subtitle":"Personal Blogs","description":"","author":"JX","url":"https://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-03-14T02:51:00.235Z","updated":"2022-03-14T02:51:00.235Z","comments":false,"path":"/404.html","permalink":"https://example.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2022-03-19T04:49:32.940Z","updated":"2022-03-19T04:49:32.940Z","comments":false,"path":"about/index.html","permalink":"https://example.com/about/index.html","excerpt":"","text":"个人详细介绍 666"},{"title":"书单","date":"2022-03-14T02:51:00.239Z","updated":"2022-03-14T02:51:00.239Z","comments":false,"path":"books/index.html","permalink":"https://example.com/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-03-14T02:51:00.241Z","updated":"2022-03-14T02:51:00.241Z","comments":true,"path":"links/index.html","permalink":"https://example.com/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-03-19T05:01:53.306Z","updated":"2022-03-14T02:51:00.240Z","comments":false,"path":"categories/index.html","permalink":"https://example.com/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-03-19T04:55:34.965Z","updated":"2022-03-14T02:51:00.242Z","comments":false,"path":"repository/index.html","permalink":"https://example.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-03-14T02:51:00.243Z","updated":"2022-03-14T02:51:00.243Z","comments":false,"path":"tags/index.html","permalink":"https://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"321","slug":"321","date":"2022-03-19T08:30:09.000Z","updated":"2022-03-19T08:30:09.313Z","comments":true,"path":"2022/03/19/321/","link":"","permalink":"https://example.com/2022/03/19/321/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"123","slug":"123","date":"2022-03-19T08:29:27.000Z","updated":"2022-03-19T08:29:33.506Z","comments":true,"path":"2022/03/19/123/","link":"","permalink":"https://example.com/2022/03/19/123/","excerpt":"","text":"fda","categories":[],"tags":[]},{"title":"https","slug":"https","date":"2022-03-19T06:08:00.000Z","updated":"2022-03-19T06:12:11.172Z","comments":true,"path":"2022/03/19/https/","link":"","permalink":"https://example.com/2022/03/19/https/","excerpt":"","text":"Https 视频&#x3D;&#x3D;&#x3D;&#x3D;》哔哩哔哩_bilibili","categories":[{"name":"服务器","slug":"服务器","permalink":"https://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Https","slug":"Https","permalink":"https://example.com/tags/Https/"}]},{"title":"Thread","slug":"Thread多线程","date":"2022-03-19T05:20:02.952Z","updated":"2022-03-19T07:00:21.984Z","comments":true,"path":"2022/03/19/Thread多线程/","link":"","permalink":"https://example.com/2022/03/19/Thread%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"线程的实现方式及其优缺点继承Thread类12345678910111213141516171819202122public class TestCode1 extends Thread&#123; private int i; public void run() &#123; for(;i&lt;100;i++) &#123; System.out.println(getName()+&quot; &quot;+i); &#125; &#125; public static void main(String[] args) &#123; for(int i=0;i&lt;100;i++) &#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+i); if(i==20)&#123; new TestCode1().start(); new TestCode1().start(); &#125; &#125; &#125;&#125; 实现Runnable接口 实现Runnable接口，重写run方法，实例要作为Thread的target来创建对象，thread.start()（推荐这种，清洗可见） 1234567891011121314151617181920class MyRunnable implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+i); &#125; &#125;&#125;public class MyThread &#123; public static void main(String[] args) &#123; //创建自定义类对象 线程任务对象 MyRunnable mr = new MyRunnable(); //创建线程对象 Thread t = new Thread(mr, &quot;小强&quot;); t.start(); for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;旺财 &quot; + i); &#125; &#125;&#125; 或者在方法内直接重写 12345678910111213public class MyThread &#123; public static void main(String[] args) &#123; Runnable r = new Runnable()&#123; public void run()&#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;张宇:&quot;+i); &#125; &#125; &#125;; new Thread(r).start(); &#125;&#125; 直接lambda创建Runnable实现类 12345678910public class MyThread &#123; public static void main(String[] args) &#123; Runnable r = () -&gt; &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;张宇:&quot;+i); &#125; &#125;; new Thread(r).start(); &#125;&#125; 实现Callable接口 创建Callable接口的实现类，并实现Call（）方法，该方法将作为线程执行体，且该方法有返回值，再创建Callable实现类的实例。从Java8开始，可以直接使用Lambda表达式创建Callable对象。 使用FutureTask来包装Callable对象，该FutureTask对象封装了该Callable对象的call方法的返回值。 使用FutureTask对象作为Thread对象的target创建并启动新线程。 调用FutureTask对象的get（）方法来获取子线程执行结束后的返回值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class MyCallable implements Callable &#123; @Override public Object call() throws Exception &#123; int i = 0; for (; i &lt; 100; i++) &#123; Thread.sleep(100); System.out.println(Thread.currentThread().getName() + &quot;循环遍历i的值&quot; + i); &#125; return null; &#125;&#125;public class ThreadTest &#123; public static void main(String[] args) &#123; Callable myCallable = new MyCallable(); FutureTask task = new FutureTask(myCallable); new Thread(task).start(); for (int i = 0; i &lt; 100; i++) &#123; try &#123; Thread.sleep(100); System.out.println(Thread.currentThread().getName()+&quot;循环遍历i的值&quot; + i); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;//lambda方式public class ThreadTest &#123; public static void main(String[] args) &#123; FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(()-&gt;&#123; int i=0; for(;i&lt;100;i++)&#123; System.out.println(Thread.currentThread().getName()+&quot;循环变量i的值：&quot;+i); &#125; return i; &#125;); for(int i=0;i&lt;100;i++)&#123; System.out.println(Thread.currentThread().getName()+&quot;循环变量i的值：&quot;+i); if(i==20)&#123; new Thread(task,&quot;有返回值的线程&quot;).start(); &#125; try&#123; System.out.println(&quot;子线程的返回值：&quot;+task.get()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 异同点和优缺点异同点 相同点 都可以实现多线程 Runnable与Callable实现方式类似 不同点 Thread方式是通过继承来实现。 Runnable与Callable是通过实现接口方式创建线程。 Runnable与Callable 因为通过FutureTask包装Callable接口，FutureTask有get方法可以获取返回值，所以只有这种方式创建的子线程有返回值。 run方法无法抛出异常，call方法可以抛出checked exception。 Callable和Runnable都可以应用于executors。而Thread类只支持Runnable. 优缺点 优点 Thread 编写简单，如果需要访问当前线程，则无须使用Thread.currentThread（）方法，直接使用this即可获得当前线程。 Runnable与Callable 可以继承其他类 多个线程可以共享一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。 缺点 Thread 继承的局限性，不能继承其他类 Runnable与Callable 编程稍稍复杂，如果需要访问当前线程，则必须使用Thread.currentThread（）方法。 补充扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用 java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进 程。 子线程执行完，主线程执行正常如1中的各种实现方式 Local跳转方式，Shimo跳转方式，主线程与子线程是争夺线程资源的，所以一般情况是会出现类似交替执行的状况。 FutureTask来包装Callable对象上方（ Local跳转方式，Shimo跳转方式）的这种是子线程无返回值的情况，这种情况下，子线程与多线程可以争夺线程资源， 如果为子线程添加返回值，使用 FutureTask来包装Callable对象，通过task.get()来获取返回值，主线程进行到task.get()时，如果子线程还在执行，没有返回，主线程就会子线程返回之前等待挂起。从而达到要求。 1234567891011121314151617181920212223public class TestCode3 &#123; public static void main(String[] args) &#123; FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;((Callable&lt;Integer&gt;)()-&gt;&#123; int i=0; for(;i&lt;100;i++)&#123; System.out.println(Thread.currentThread().getName()+&quot;循环变量i的值：&quot;+i); &#125; return i; &#125;); for(int i=0;i&lt;100;i++)&#123; System.out.println(Thread.currentThread().getName()+&quot;循环变量i的值：&quot;+i); if(i==20)&#123; new Thread(task,&quot;有返回值的线程&quot;).start(); &#125; try&#123; System.out.println(&quot;子线程的返回值：&quot;+task.get()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; join方法参考资料链接 结论：t.join()方法只会使主线程(或者说调用t.join()的线程)进入等待池并等待t线程执行完毕后才会被唤醒。并不影响同一时刻处在运行状态的其他线程。 t.join方法底层中使用wait(0)方法，即使用了该方法的线程会进入无限等待中，直到 t 执行完成才返回。进入等待的只是调用了join方法的线程，其他线程没开启的不会开启，开启了的不会等待继续执行。 1234567891011121314151617181920public class TestJoin &#123; public static void main(String[] args) throws InterruptedException &#123; // TODO Auto-generated method stub System.out.println(Thread.currentThread().getName()+&quot; start&quot;); ThreadTest t1=new ThreadTest(&quot;A&quot;); ThreadTest t2=new ThreadTest(&quot;B&quot;); ThreadTest t3=new ThreadTest(&quot;C&quot;); System.out.println(&quot;t1start&quot;); t1.start(); System.out.println(&quot;t1end&quot;); System.out.println(&quot;t2start&quot;); t2.start(); System.out.println(&quot;t2end&quot;); t1.join(); System.out.println(&quot;t3start&quot;); t3.start(); System.out.println(&quot;t3end&quot;); System.out.println(Thread.currentThread().getName()+&quot; end&quot;); &#125;&#125; 结果： 1234567891011121314151617181920212223main startt1startt1endt2startt2endA-1B-1A-2A-3A-4A-5B-2t3startt3endB-3main endB-4B-5C-1C-2C-3C-4C-5 主线程在t1.join()方法处停止，并需要等待A线程执行完毕后才会执行t3.start()，然而，并不影响B线程的执行。因此，可以得出结论，t.join()方法只会使主线程进入等待池并等待t线程执行完毕后才会被唤醒。并不影响同一时刻处在运行状态的其他线程。 join源码中，只会调用wait方法，并没有在结束时调用notify，这是因为&#x3D;&#x3D;线程在die的时候会自动调用自身的notifyAll方法，来释放所有的资源和锁。&#x3D;&#x3D; 线程与线程池的状态线程的状态（NRBWTT）（牛肉包我舔舔） NEW 尚未启动 RUNNABLE 正在执⾏中 BLOCKED 阻塞的（被同步锁或者IO锁阻塞） WAITING 永久等待状态 TIMED_WAITING 等待指定的时间重新被唤醒的状态 TERMINATED 执⾏完成 线程池的状态（RSSTT）（人事是傻甜甜） RUNNING： 这是最正常的状态 ，接受新的任务，处理等待队列中的任务 。 SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。 STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执⾏任务的线程。 TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执⾏钩⼦⽅法 terminated()。 TERMINATED：terminated()⽅法结束后，线程池的状态就会变成这个。 线程池大佬链接&#x3D;&#x3D;&#x3D;&#x3D;》线程池1_CSDN博客 大佬链接&#x3D;&#x3D;&#x3D;&#x3D;》线程池2-CSDN博客 线程池的优点 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 线程池的继承树 线程池地使用线程池的真正实现类是ThreadPoolExecutor ，其构造器方法有以下4种： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler);&#125; public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler);&#125; public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 参数说明： IPHP corePoolSize（必需）：核心线程数。默认情况下，核心线程会一直存活，但是当将 allowCoreThreadTimeout 设置为 true 时，核心线程也会超时回收。 maximumPoolSize（必需）：线程池所能容纳的最大线程数。当活跃线程数达到该数值后，后续的新任务将会阻塞。 keepAliveTime（必需）：线程闲置超时时长。如果超过该时长，非核心线程就会被回收。如果将 allowCoreThreadTimeout 设置为 true 时，核心线程也会超时回收。 unit（必需）：指定 keepAliveTime 参数的时间单位。常用的有：TimeUnit.MILLISECONDS（毫秒）、TimeUnit.SECONDS（秒）、TimeUnit.MINUTES（分）。 workQueue（必需）：任务队列。通过线程池的 execute() 方法提交的 Runnable 对象将存储在该参数中。其采用阻塞队列实现。 threadFactory（可选）：线程工厂。用于指定为线程池创建新线程的方式。 handler（可选）：拒绝策略。当达到最大线程数时需要执行的饱和策略。 线程池的使用流程： 1234567891011121314151617// 创建线程池ThreadPoolExecutor threadPool = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);// 向线程池提交任务threadPool.execute(new Runnable() &#123; @Override public void run() &#123; ... // 线程执行的任务 &#125;&#125;);// 关闭线程池threadPool.shutdown(); // 设置线程池的状态为SHUTDOWN，然后中断所有没有正在执行任务的线程threadPool.shutdownNow(); // 设置线程池的状态为 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表 线程池的工作原理 简概： IPHP 1.如果线程数小于corePoolSize，创建一个新核心线程来运行新任务。 2.如果线程数大于等于corePoolSize但小于maximumPoolSize，则将任务放入队列。 3.如果队列已满，并且线程数小于maxPoolSize，则创建一个新非核心线程来运行任务。 4.如果队列已满，并且线程数大于或等于maxPoolSize，则拒绝该任务。 是否需要增加线程的判断顺序是：1、corePoolSize 2、workQueue 3、maxPoolSize 举个例子： 线程池的核心线程数corePoolSize大小为5，最大池maxPoolSize大小为10，队列workQueue为100。 因为线程中的请求最多会创建5个，然后任务将被添加到队列中，直到达到100。当队列已满时，将创建新的线程，最多到10个线程，如果再来任务，就拒绝。 特点： 通过设置corePoolSize和maximumPoolSize 相同，就可以创建固定大小的线程池。 我们使用线程池一般希望保持较少的线程数，并且只有在负载变得很大时才增加它。 通过设置maximumPoolSize为很高的值，例如 Integer.MAX_VALUE，可以允许线程池容纳任意数量的并发任务。 只有在队列填满时才创建多于corePoolSize的非核心线程，如果使用的是无界队列（例如LinkedBlockingQueue），那么线程数就不会超过corePoolSize。 线程参数解析任务队列workQueue任务队列是基于阻塞队列实现的，即采用生产者消费者模式，在 Java 中需要实现 BlockingQueue 接口。但 Java 已经为我们提供了 7 种阻塞队列的实现： ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列（数组结构可配合指针实现一个环形队列）。 LinkedBlockingQueue： 一个由链表结构组成的有界阻塞队列，在未指明容量时，容量默认为Integer.MAX_VALUE。 这种队列容量无限大，可以防止流量突增。设置maximumPoolSize也用不到，因为队列装不满，永远不需要创建新的非核心线程。但是也有风险，处理任务的速度跟不上提交的速度，可能造成内存浪费或者OOM。 PriorityBlockingQueue： 一个支持优先级排序的无界阻塞队列，对元素没有要求，可以实现 Comparable 接口也可以提供 Comparator 来对队列中的元素进行比较。跟时间没有任何关系，仅仅是按照优先级取任务。 DelayQueue：类似于PriorityBlockingQueue，是二叉堆实现的无界优先级阻塞队列。要求元素都实现 Delayed 接口，通过执行时延从队列中提取任务，时间没到任务取不出来。 SynchronousQueue： 一个不存储元素的阻塞队列，消费者线程调用 take() 方法的时候就会发生阻塞，直到有一个生产者线程生产了一个元素，消费者线程就可以拿到这个元素并返回；生产者线程调用 put() 方法的时候也会发生阻塞，直到有一个消费者线程消费了一个元素，生产者才会返回。 工作任务不多的情况下，只是将任务中转，就可以用SynchronousQueue，这个队列本身内部没有容量，使用这种队列，maximumPoolSize就可能需要设置的大一些。因为没有队列容量作为缓冲了，很容易创建新线程。 LinkedBlockingDeque： 使用双向队列实现的有界双端阻塞队列。双端意味着可以像普通队列一样 FIFO（先进先出），也可以像栈一样 FILO（先进后出）。 LinkedTransferQueue： 它是ConcurrentLinkedQueue、LinkedBlockingQueue 和 SynchronousQueue 的结合体，但是把它用在 ThreadPoolExecutor 中，和 LinkedBlockingQueue 行为一致，但是是无界的阻塞队列。 注意有界队列和无界队列的区别：如果使用有界队列，当队列饱和时并超过最大线程数时就会执行拒绝策略；而如果使用无界队列，因为任务队列永远都可以添加任务，所以设置 maximumPoolSize 没有任何意义。 线程工厂（threadFactory）线程工厂指定创建线程的方式，需要实现 ThreadFactory 接口，并实现 newThread(Runnable r) 方法。 新的线程是由ThreadFactory创建的，默认使用Executors.defaultThreadFactory() 创建出来的线程都在同一个线程组，拥有同样的NORM_PRIORITY优先级并且都不是守护线程。 如果自己指定ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等。 通常使用默认的ThreadFactory就可以了 12345678910111213141516171819202122232425262728293031323334// 验证第一点，新的线程是由ThreadFactory创建的，默认使用Executors.defaultThreadFactory()public static ThreadFactory defaultThreadFactory() &#123; return new DefaultThreadFactory();&#125;......static class DefaultThreadFactory implements ThreadFactory &#123; private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; DefaultThreadFactory() &#123; SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = &quot;pool-&quot; + poolNumber.getAndIncrement() + &quot;-thread-&quot;; &#125; public Thread newThread(Runnable r) &#123; // 验证第二点，创建出来的线程都在同一个线程组，拥有同样的NORM_PRIORITY优先级并且都不是守护线程。 Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); if (t.isDaemon()) t.setDaemon(false); if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; &#125; &#125; 拒绝策略（handler）当线程池的线程数达到最大线程数时，需要执行拒绝策略。拒绝策略需要实现 RejectedExecutionHandler 接口，并实现 rejectedExecution(Runnable r, ThreadPoolExecutor executor) 方法。不过 Executors 框架已经为我们实现了 4 种拒绝策略： AbortPolicy（默认）：丢弃任务并抛出 RejectedExecutionException 异常。 CallerRunsPolicy：由调用线程处理该任务。 DiscardPolicy：丢弃任务，但是不抛出异常。可以配合这种模式进行自定义的处理方式。 DiscardOldestPolicy：丢弃队列最早的未处理任务，然后重新尝试执行任务。 功能线程池嫌上面使用线程池的方法太麻烦？其实Executors已经为我们封装好了 4 种常见的功能线程池，如下： 定长线程池（FixedThreadPool） 定时线程池（ScheduledThreadPool ） 可缓存线程池（CachedThreadPool） 单线程化线程池（SingleThreadExecutor） 定长线程池（FixedThreadPool）1234567891011public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory);&#125; 特点：只有核心线程，线程数量固定，执行完立即回收，任务队列为链表结构的有界队列。 应用场景：控制线程最大并发数。 使用： 12345678910// 1. 创建定长线程池对象 &amp; 设置线程池线程数量固定为3ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);// 2. 创建好Runnable类线程对象 &amp; 需执行的任务Runnable task =new Runnable()&#123; public void run() &#123; System.out.println(&quot;执行任务啦&quot;); &#125;&#125;;// 3. 向线程池提交任务fixedThreadPool.execute(task); 定时线程池（ScheduledThreadPool ）12345678910111213141516171819202122private static final long DEFAULT_KEEPALIVE_MILLIS = 10L; public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue());&#125; public static ScheduledExecutorService newScheduledThreadPool( int corePoolSize, ThreadFactory threadFactory) &#123; return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);&#125;public ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue(), threadFactory);&#125; 特点：核心线程数量固定，非核心线程数量无限，执行完闲置 10ms 后回收，任务队列为延时阻塞队列。 应用场景：执行定时或周期性的任务。 1234567891011// 1. 创建 定时线程池对象 &amp; 设置线程池线程数量固定为5ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);// 2. 创建好Runnable类线程对象 &amp; 需执行的任务Runnable task =new Runnable()&#123; public void run() &#123; System.out.println(&quot;执行任务啦&quot;); &#125;&#125;;// 3. 向线程池提交任务scheduledThreadPool.schedule(task, 1, TimeUnit.SECONDS); // 延迟1s后执行任务scheduledThreadPool.scheduleAtFixedRate(task,10,1000,TimeUnit.MILLISECONDS);// 延迟10ms后、每隔1000ms执行任务 可缓存线程池（CachedThreadPool）123456789101112public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125;public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), threadFactory);&#125; 特点：无核心线程，非核心线程数量无限，执行完闲置 60s 后回收，任务队列为不存储元素的阻塞队列。 应用场景：执行大量、耗时少的任务。 12345678910// 1. 创建可缓存线程池对象ExecutorService cachedThreadPool = Executors.newCachedThreadPool();// 2. 创建好Runnable类线程对象 &amp; 需执行的任务Runnable task =new Runnable()&#123; public void run() &#123; System.out.println(&quot;执行任务啦&quot;); &#125;&#125;;// 3. 向线程池提交任务cachedThreadPool.execute(task) 单线程化线程池（SingleThreadExecutor）12345678910111213public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory));&#125; 特点：只有 1 个核心线程，无非核心线程，执行完立即回收，任务队列为链表结构的有界队列。 应用场景：不适合并发但可能引起 IO 阻塞性及影响 UI 线程响应的操作，如数据库操作、文件操作等。 12345678910// 1. 创建单线程化线程池ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();// 2. 创建好Runnable类线程对象 &amp; 需执行的任务Runnable task =new Runnable()&#123; public void run() &#123; System.out.println(&quot;执行任务啦&quot;); &#125;&#125;;// 3. 向线程池提交任务singleThreadExecutor.execute(task); 对比 线程池模板大佬链接&#x3D;&#x3D;&#x3D;&#x3D;》Spring线程池配置模板- 博客园 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475@EnableAsync@Configurationpublic class LogThreadPoolConfig &#123; @Bean(name = &quot;logThreadPool&quot;) public ThreadPoolTaskExecutor LogThreadPoolTask() &#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); LogThreadPoolProperties properties = this.logThreadPoolProperties(); executor.setCorePoolSize(properties.getCorePoolSize()); executor.setMaxPoolSize(properties.getMaxPoolSize()); executor.setQueueCapacity(properties.getQueueCapacity()); executor.setKeepAliveSeconds(properties.getKeepAliveSeconds()); executor.setThreadNamePrefix(properties.getThreadName()); switch (properties.getRejectedExecutionHandler()) &#123; case &quot;abortPolicy&quot;: executor.setRejectedExecutionHandler(new AbortPolicy()); break; case &quot;callerRunsPolicy&quot;: executor.setRejectedExecutionHandler(new CallerRunsPolicy()); break; case &quot;discardOldestPolicy&quot;: executor.setRejectedExecutionHandler(new DiscardOldestPolicy()); break; case &quot;discardPolicy&quot;: executor.setRejectedExecutionHandler(new DiscardOldestPolicy()); break; default: executor.setRejectedExecutionHandler(new CallerRunsPolicy()); break; &#125; executor.initialize(); return executor; &#125; @Bean @ConfigurationProperties(prefix = &quot;threadpool.log&quot;) public LogThreadPoolProperties logThreadPoolProperties() &#123; return new LogThreadPoolProperties(); &#125; //@Getter lombok提供的getset方法生成注解 //@Setter @Configuration public static class LogThreadPoolProperties &#123; /** * 线程前缀名 */ private String threadName; /** * 核心线程池大小 */ private int corePoolSize; /** * 最大线程数 */ private int maxPoolSize; /** * 队列大小 */ private int queueCapacity; /** * 线程池维护空闲线程存在时间 */ private int keepAliveSeconds; /** * 拒绝策略 */ private String rejectedExecutionHandler; &#125;&#125; 这样就可以在yml文件中配置参数了： 123456789threadpool: log: threadName: ThreadPool-log- # 线程池前缀名 corePoolSize: 8 # 核心线程池数：IO型推荐设置为cpu核心数*2；cpu型推荐设置为cpu数+1 maxPoolSize: 16 # 最大线程池数 queueCapacity: 1000 # 线程池阻塞队列容量 keepAliveSeconds: 60 # 允许线程空闲时间 # 拒绝策略 abortPolicy callerRunsPolicy discardOldestPolicy discardPolicy rejectedExecutionHandler: callerRunsPolicy 使用： Spring提供了注解方式来方便我们使用线程池，只需要在要异步处理的方法上加 @Async(“你配置的线程池名字”)就可以了,注意这个类需要被spring扫描并纳入管理，所以要加@Service、@Component等注解。 123456789@Servicepublic class ServiceImpl implements Service &#123; @Override @Async(&quot;logThreadPool&quot;) public void addOperationLog(BaseLog baseLog) &#123; //你要异步执行的逻辑 &#125;&#125; 小总结 &#x3D;&#x3D;Executors 的 4 个功能线程池虽然方便，但现在已经不建议使用了，而是建议直接通过使用 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。&#x3D;&#x3D; 其实 Executors 的 4 个功能线程有如下弊端： FixedThreadPool 和 SingleThreadExecutor：主要问题是堆积的请求处理队列均采用 LinkedBlockingQueue，可能会耗费非常大的内存，甚至 OOM。 CachedThreadPool 和 ScheduledThreadPool：主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM。 线程池里的线程数量设定为多少比较合适？ 这个得看任务类型 CPU密集型（加密、计算hash等）：最佳线程数为CPU核心数的1-2倍左右。 耗时IO型（读写数据库、文件、网络读写等）：最佳线程数一般会大于CPU核心数很多倍 ，参考Brain Goetz专家推荐的计算方法：线程数&#x3D;CPU核心数*（1+平均等待时间&#x2F;平均工作时间） 如果需要更精确的线程数量，那就需要根据不同的程序去做压测，这样就能得到比较合适的线程数量。 ThreadLocal概念ThreadLocal叫做线程变量，ThreadLocal中填充的变量 属于当前线程，该变量对其他线程而言是隔离的。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。 ThreadLocal 适用于每个线程变量在线程间隔离而在方法或类间共享的场景。 ThreadLocal与Synchronized的区别 ThreadLocal ThreadLocal则用于线程间的数据隔离。ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象 Synchronized Synchronized用于线程间的数据共享。利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。 使用1234567891011121314151617181920212223242526272829303132333435363738public class ThreadLocaDemo &#123; private static ThreadLocal&lt;String&gt; localVar = new ThreadLocal&lt;String&gt;(); static void print(String str) &#123; //打印当前线程中本地内存中本地变量的值 System.out.println(str + &quot; :&quot; + localVar.get()); //清除本地内存中的本地变量 localVar.remove(); &#125; public static void main(String[] args) throws InterruptedException &#123; new Thread(new Runnable() &#123; public void run() &#123; ThreadLocaDemo.localVar.set(&quot;local_A&quot;); print(&quot;A&quot;); //打印本地变量 System.out.println(&quot;after remove : &quot; + localVar.get()); &#125; &#125;,&quot;A&quot;).start(); Thread.sleep(1000); new Thread(new Runnable() &#123; public void run() &#123; ThreadLocaDemo.localVar.set(&quot;local_B&quot;); print(&quot;B&quot;); System.out.println(&quot;after remove : &quot; + localVar.get()); &#125; &#125;,&quot;B&quot;).start(); &#125;&#125;A :local_Aafter remove : nullB :local_Bafter remove : null set()&#x3D;&#x3D;向ThreadLocal里面存东西就是向它里面的Map存东西的，然后ThreadLocal把这个Map挂到当前的线程底下&#x3D;&#x3D; 123456789101112public void set(T value) &#123; //1、获取当前线程 Thread t = Thread.currentThread(); //2、获取线程中的属性 threadLocalMap ,如果threadLocalMap 不为空， //则直接更新要保存的变量值，否则创建threadLocalMap，并赋值 ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else // 初始化thradLocalMap 并赋值 createMap(t, value); &#125; 从上面的代码可以看出，ThreadLocal set赋值的时候首先会获取当前线程thread,并获取thread线程中的ThreadLocalMap属性。如果map属性不为空，则直接更新value值，如果map为空，则实例化threadLocalMap,并将value值初始化。 &#x3D;&#x3D;ThreadLocalMap呢是当前线程Thread一个叫threadLocals的变量中获取的。每个线程Thread都维护了自己的threadLocals变量，所以在每个线程创建ThreadLocal的时候，实际上数据是存在自己线程Thread的threadLocals变量里面的，别人没办法拿到，从而实现了隔离。&#x3D;&#x3D; 123ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125; 12345678910111213141516171819static class ThreadLocalMap &#123; /** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as &quot;stale entries&quot; in the code that follows. */ static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; &#125; 可看出ThreadLocalMap是ThreadLocal的内部静态类，而它的构成主要是用Entry来保存数据 ，而且还是继承的弱引用。在Entry内部使用ThreadLocal作为key，使用我们设置的value作为value。IPHP 姬祥todo createMap get()1234567891011121314151617181920212223242526272829 public T get() &#123; //1、获取当前线程 Thread t = Thread.currentThread(); //2、获取当前线程的ThreadLocalMap ThreadLocalMap map = getMap(t); //3、如果map数据为空， if (map != null) &#123; //3.1、获取threalLocalMap中存储的值 ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; //如果是数据为null，则初始化，初始化的结果，TheralLocalMap中存放key值为threadLocal，值为null return setInitialValue(); &#125; private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value; &#125; remove()12345 public void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this);&#125; remove方法，直接将ThrealLocal 对应的值从当前相差Thread中的ThreadLocalMap中删除。为什么要删除，这涉及到内存泄露的问题。 如上所说（Local跳转方式，Shimo跳转方式）， ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉。 所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。这样就造成了内存泄露。 ThreadLocal与Thread，ThreadLocalMap之间的关系 ThreadLocal 常见使用场景参考&#x3D;&#x3D;&#x3D;&#x3D;》ThreadLocal的应用场景 - sw_kong - 博客园 (cnblogs.com) 场景的需求： 每个线程需要有自己单独的实例 实例需要在多个方法中共享，但不希望变量被多线程共享 ThreadLocal 用作每个线程内需要独立保存信息，以便供其他方法更方便地获取该信息的场景。每个线程获取到的信息可能都是不一样的，前面执行的方法保存了信息后，后续方法可以通过ThreadLocal 直接获取到，避免了传参，类似于全局变量的概念。 SimpleDateFormat（Java8里的 java.time.format.DateTimeFormatter 是线程安全的 ，由于它调用的parseResolved0 方法入参都是final 修饰的，不可变变量是线程安全的。） 当时我们使用SimpleDataFormat的parse()方法，内部有一个Calendar对象，调用SimpleDataFormat的parse()方法会先调用Calendar.clear（），然后调用Calendar.add()。ThreadLocal_敖丙-CSDN博客。如果一个线程先调用了add()然后另一个线程又调用了clear()，这时候parse()方法解析的时间就不对了。 在这种情况下，每个Thread内都有自己的实例副本，且该副本只能由当前Thread访问到并使用，相当于每个线程内部的本地变量，这也是ThreadLocal命名的含义。因为每个线程独享副本，而不是公用的，所以不存在多线程间共享的问题。 比如有1000个线程都要用到SimpleDateFormat 1234567891011121314151617181920212223public class ThreadLocalDemo011 &#123; public static ExecutorService threadPool = Executors.newFixedThreadPool(16); public static void main(String[] args) throws InterruptedException &#123; for (int i = 0; i &lt; 1000; i++) &#123; int finalI = i; threadPool.submit(() -&gt; &#123; String data = new ThreadLocalDemo011().date(finalI); System.out.println(data); &#125;); &#125; threadPool.shutdown(); &#125; public static Integer id= 0; private String date(int seconds)&#123; Date date = new Date(1000 * seconds); id++; System.out.println(id+&quot;=============&quot;); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;mm:ss&quot;); return simpleDateFormat.format(date); &#125;&#125; 可以看出，我们用了一个16线程的线程池，并且给这个线程池提交了1000次任务。每个任务中它做的事情和之前是一样的，还是去执行date方法，并且在这个方法中创建一个simpleDateFormat 对象。近1000个simpleDateFormat 对象会被创建。 这么多对象的创建是有开销的，并且在使用完之后的销毁同样是有开销的，同时存在在内存中也是一种内存的浪费。 我们可能会想到，要不所有的线程共用一个 simpleDateFormat 对象？但是simpleDateFormat 又不是线程安全的，我们必须做同步，比如使用synchronized加锁。到这里也许就是我们最终的一个解决方法。但是使用synchronized加锁会陷入一种排队的状态，多个线程不能同时工作，这样一来，整体的效率就被大大降低了。 使用ThreadLocal 对这种场景，ThreadLocal再合适不过了，ThreadLocal给每个线程维护一个自己的simpleDateFormat对象，这个对象在线程之间是独立的，互相没有关系的。这也就避免了线程安全问题。与此同时，simpleDateFormat对象还不会创造过多，线程池一共只有 16 个线程，所以需要16个对象即可。 12345678910111213141516171819202122232425262728293031public class ThreadLocalDemo04 &#123; public static ExecutorService threadPool = Executors.newFixedThreadPool(16); public static void main(String[] args) throws InterruptedException &#123; for (int i = 0; i &lt; 1000; i++) &#123; int finalI = i; threadPool.submit(() -&gt; &#123; String data = new ThreadLocalDemo04().date(finalI); System.out.println(data); &#125;); &#125; threadPool.shutdown(); &#125; private String date(int seconds)&#123; Date date = new Date(1000 * seconds); SimpleDateFormat dateFormat = ThreadSafeFormater.dateFormatThreadLocal.get(); return dateFormat.format(date); &#125;&#125;class ThreadSafeFormater&#123; public static Integer id= 0; public static ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal = ThreadLocal.withInitial(() -&gt; &#123; id++; System.out.println(id+&quot;=============&quot;); return new SimpleDateFormat(&quot;mm:ss&quot;); &#125;);&#125; 结果： 可以看出只创建了16个SimpleDateFormat对象。 123456789101112131415161718192021222324251=============4=============5=============6=============3=============7=============2=============8=============9=============10=============11=============13=============12=============14=============15=============16=============00:0900:1600:17................16:0516:0416:0316:02 问题： 这种情况每个线程的SimpleDataFormat的parse()方法，在一个任务执行后其他任务继续使用这个线程执行任务时，会不会造成数据混乱。 答案 不会，SimpleDataFormat的parse()方法，内部有一个Calendar对象，调用SimpleDataFormat的parse()方法会先调用Calendar.clear()清除数据，然后调用Calendar.add()添加数据。 用户信息（类似线程内的全局变量）每个线程内需要保存类似于全局变量的信息（例如在拦截器中获取的用户信息），可以让不同方法直接使用，避免参数传递的麻烦却不想被多线程共享（因为不同线程获取到的用户信息不一样）。 例如，用 ThreadLocal 保存一些业务内容（用户权限信息、从用户系统获取到的用户名、用户ID 等），这些信息在同一个线程内相同，但是不同的线程使用的业务内容是不相同的。 在线程生命周期内，都通过这个静态 ThreadLocal 实例的 get() 方法取得自己 set 过的那个对象，避免了将这个对象（如 user 对象）作为参数传递的麻烦。 比如说我们是一个用户系统，那么当一个请求进来的时候，一个线程会负责执行这个请求，然后这个请求就会依次调用service-1()、service-2()、service-3()、service-4()，这4个方法可能是分布在不同的类中的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.kong.threadlocal;public class ThreadLocalDemo05 &#123; public static void main(String[] args) &#123; User user = new User(&quot;jack&quot;); new Service1().service1(user); &#125;&#125;class Service1 &#123; public void service1(User user)&#123; //给ThreadLocal赋值，后续的服务直接通过ThreadLocal获取就行了。 UserContextHolder.holder.set(user); new Service2().service2(); &#125;&#125;class Service2 &#123; public void service2()&#123; User user = UserContextHolder.holder.get(); System.out.println(&quot;service2拿到的用户:&quot;+user.name); new Service3().service3(); &#125;&#125;class Service3 &#123; public void service3()&#123; User user = UserContextHolder.holder.get(); System.out.println(&quot;service3拿到的用户:&quot;+user.name); //在整个流程执行完毕后，一定要执行remove UserContextHolder.holder.remove(); &#125;&#125;class UserContextHolder &#123; //创建ThreadLocal保存User对象 public static ThreadLocal&lt;User&gt; holder = new ThreadLocal&lt;&gt;();&#125;class User &#123; String name; public User(String name)&#123; this.name = name; &#125;&#125; 守护线程面试题线程池创建的4中方法Local跳转方式，Shimo跳转方式 任务加入的线程池的流程Local跳转方式，Shimo跳转方式 线程池的7个参数。拒绝策略。参数：Local跳转方式，Shimo跳转方式 拒绝策略：Local跳转方式，Shimo跳转方式 线程池中如何拿到线程的执行结果线程池中 submit()和 execute()方法有什么区别？ execute()：只能执⾏ Runnable 类型的任务。 submit()：可以执⾏ Runnable 和 Callable 类型的任务。 死锁两线程都有各自的锁，并都尝试去获取独占对方的锁，就会发生阻塞的现象。 解释下生产消费模型生产者消费者能够解决的问题如下： 生产与消费的速度不匹配 软件开发过程中解耦 生产者生产，消费者消费，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架满的时候，消费者可以从货架上拿走商品，生产者此时等待货架的空位，这样不断的循环。那么在这个过程中，生产者和消费者是不直接接触的，所谓的‘货架’其实就是一个&#x3D;&#x3D;阻塞队列&#x3D;&#x3D;，生产者生产的产品不直接给消费者消费，而是仍给阻塞队列，这个阻塞队列就是来解决生产者消费者的强耦合的。就是生产者消费者模型。TP①，TP② 参考 ThreadLocal原理分析与使用场景 - 阿凡卢 - 博客园 (cnblogs.com) ThreadLocal的应用场景 - sw_kong - 博客园 (cnblogs.com) ThreadLocal_敖丙-CSDN博客 CSDN博客_生产者消费者模型 Java8之Consumer、Supplier、Predicate和Function攻略 博客园","categories":[{"name":"java","slug":"java","permalink":"https://example.com/categories/java/"}],"tags":[{"name":"Thread","slug":"Thread","permalink":"https://example.com/tags/Thread/"}]},{"title":"SpringCloud alibaba","slug":"SpringCloud-alibaba","date":"2022-03-19T05:20:02.949Z","updated":"2022-03-19T05:19:18.107Z","comments":true,"path":"2022/03/19/SpringCloud-alibaba/","link":"","permalink":"https://example.com/2022/03/19/SpringCloud-alibaba/","excerpt":"","text":"SpringCloud alibaba","categories":[{"name":"java","slug":"java","permalink":"https://example.com/categories/java/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://example.com/tags/SpringCloud/"}]},{"title":"SpringBoot","slug":"Springboot","date":"2022-03-19T05:20:02.947Z","updated":"2022-03-19T06:53:40.694Z","comments":true,"path":"2022/03/19/Springboot/","link":"","permalink":"https://example.com/2022/03/19/Springboot/","excerpt":"","text":"SpringBoot5. web开发3. 请求参数处理1. 普通参数与基本注解1.1注解视频&#x3D;&#x3D;&#x3D;&#x3D;》尚硅谷雷神SpringBoot2_bilibili @PathVariable、 @RequestHeader、 @ModelAttribute、 @RequestParam、 @MatrixVariable（矩阵变量）、 @CookieValue、 @RequestBody 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@RestControllerpublic class ParameterTestController &#123; // car/2/owner/zhangsan @GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;) public Map&lt;String,Object&gt; getCar(@PathVariable(&quot;id&quot;) Integer id, @PathVariable(&quot;username&quot;) String name, @PathVariable Map&lt;String,String&gt; pv, @RequestHeader(&quot;User-Agent&quot;) String userAgent, @RequestHeader Map&lt;String,String&gt; header, @RequestParam(&quot;age&quot;) Integer age, @RequestParam(&quot;inters&quot;) List&lt;String&gt; inters, @RequestParam Map&lt;String,String&gt; params, @CookieValue(&quot;_ga&quot;) String _ga, @CookieValue(&quot;_ga&quot;) Cookie cookie)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();// map.put(&quot;id&quot;,id);// map.put(&quot;name&quot;,name);// map.put(&quot;pv&quot;,pv);// map.put(&quot;userAgent&quot;,userAgent);// map.put(&quot;headers&quot;,header); map.put(&quot;age&quot;,age); map.put(&quot;inters&quot;,inters); map.put(&quot;params&quot;,params); map.put(&quot;_ga&quot;,_ga); System.out.println(cookie.getName()+&quot;===&gt;&quot;+cookie.getValue()); return map; &#125; @PostMapping(&quot;/save&quot;) public Map postMethod(@RequestBody String content)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;content&quot;,content); return map; &#125; //1、语法： 请求路径：/cars/sell;low=34;brand=byd,audi,yd //2、SpringBoot默认是禁用了矩阵变量的功能 // 手动开启：原理。对于路径的处理。UrlPathHelper进行解析。 // removeSemicolonContent（移除分号内容）支持矩阵变量的 //3、矩阵变量必须有url路径变量才能被解析 @GetMapping(&quot;/cars/&#123;path&#125;&quot;) public Map carsSell(@MatrixVariable(&quot;low&quot;) Integer low, @MatrixVariable(&quot;brand&quot;) List&lt;String&gt; brand, @PathVariable(&quot;path&quot;) String path)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;low&quot;,low); map.put(&quot;brand&quot;,brand); map.put(&quot;path&quot;,path); return map; &#125; // /boss/1;age=20/2;age=10 @GetMapping(&quot;/boss/&#123;bossId&#125;/&#123;empId&#125;&quot;) public Map boss(@MatrixVariable(value = &quot;age&quot;,pathVar = &quot;bossId&quot;) Integer bossAge, @MatrixVariable(value = &quot;age&quot;,pathVar = &quot;empId&quot;) Integer empAge)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;bossAge&quot;,bossAge); map.put(&quot;empAge&quot;,empAge); return map; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://example.com/categories/java/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://example.com/tags/SpringBoot/"}]},{"title":"MySQL","slug":"MySQL","date":"2022-03-19T05:20:02.939Z","updated":"2022-03-19T06:57:59.606Z","comments":true,"path":"2022/03/19/MySQL/","link":"","permalink":"https://example.com/2022/03/19/MySQL/","excerpt":"","text":"MySQL基础高级8、 索引的创建与设计原则2、索引的必要使用场景1). 字段的数值有唯一性的限制业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。 说明：唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。 2). 频繁作为 WHERE 查询条件的字段某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。 比如查询 student_id =144324的时候 123SELECT course_id ,class_id, `name`,create_time,student_idFROM student_info WHERE student_id =144324 在student_id不加索引的情况下，100w条数据，耗时为350ms左右，即在百毫秒级 1234ALTER TABLE student_info ADD INDEX idx_sid(student_id)SHOW INDEX FROM student_info #查看是否添加成功 在添加索引的情况下，耗时为22ms，降了一个数量级，这是很客观的。 3). 经常 GROUP BY 和 ORDER BY 的列索引就是让数据按照某种顺序进行存储或检索，因此当我们使用GROUP BY对数据进行分组查询，或者使用ORDER BY对数据进行排序的时候，就需要对分组或者排序的字段进行索引，从而减少排序的时间。如果待排序的列有多个，那么可以在这些列上建立组合索引。 1. GROUP BYeg：在100w条数据中，按照student_id对学生选修课程进行分组，显示不同的student_id和课程数量，显示100个。 123456SELECT student_id ,COUNT(*) AS numFROM student_infoGROUP BY student_id LIMIT 100DROP INDEX idx_sid ON student_infoSHOW INDEX FROM student_info 在不加索引的情况下，耗时850毫秒。 在加索引的情况下（这里使用的是2）当中的idx_sid索引），耗时21毫秒。 2. ORDER BYORDER BY单独使用的情况与GROUP BY差不多 3. ORDER BY和GROUP BY同时使用的情况&#x3D;&#x3D;由于GROUP BY先执行，且GROUP BY为先排序再分组，所以主要耗时就集中在GROUP BY上。&#x3D;&#x3D; 使用以下三种情况来观察不同索引状况下，sql执行的速度差异 三种情况： ​ ①. student_id和create_time分别建立索引 ​ ②. student_id和create_time建立联合索引，且student_id在前 ​ ③. student_id和create_time建立联合索引，且create_time在前 12345SELECT student_id,COUNT(*) AS num FROM student_infoGROUP BY student_idORDER BY create_time descLIMIT 100 不加除主键索引以外的其他索引的情况下，耗时约&#x3D;&#x3D;0.8~1s&#x3D;&#x3D; 两种版本： ​ ①. MySQL 5.7.5及以上功能依赖检测功能 ​ ②. MySQL 5.7.5以下无依赖检测功能 执行上方代码后MySQL 5.7.5及以上会报错 1sql_mode=only_full_group_by #出现问题 MySQL 5.7.5及以上由于sql_mode=only_full_group_by是默认开启依赖检测功能，所以HAVING条件或ORDER BY列表的查询引用在GROUP BY子句中。 简单来说就是：输出的结果是叫target list，就是select后面跟着的字段，还有一个地方group by column，就是group by后面跟着的字段。由于开启ONLY_FULL_GROUP_BY的设置，如果一个字段没有在target list和group by字段中同时出现，或者是聚合函数的值的话，那么这条sql查询是被mysql认为非法的，会报错误。 但是如果同时GROUP BY student_id，create_time 这两个字段，就失去了本例的作用。所以需要MySQL 5.7.5及以上的需要关闭依赖检测功能 具体解析链接&#x3D;&#x3D;&#x3D;&#x3D;》文档——石墨 12345select @@global.sql_mode #查看sql_mode详细set @@global.sql_mode =&#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#x27;; #去掉ONLY_FULL_GROUP_BY，重新设置值，对于新建的数据库有效 8.0中还要去掉NO_AUTO_CREATE_USERset global sql_mode=&#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#x27;; #对于已存在的数据库，则需要在对应的数据下执行 继续测试 添加单列student_id索引和create_time索引 ​ 5.7中： 耗时6s左右，添加索引就是将这些时间提前消耗掉，让客户查询的时候减少查询时间。 12345ALTER TABLE student_infoADD INDEX idx_sid(student_id);ALTER TABLE student_infoADD INDEX idx_cre_time(create_time DESC); 这里 EXPLAIN 后会发现只使用了student_id 的索引idx_sid（单列索引的情况，只使用语句执行过程第一个索引）所以这里只使用了索引idx_sid，而idx_cre_time压根没用到。 123456789SHOW INDEX FROM student_infoEXPLAIN SELECT student_id,COUNT(*) AS num FROM student_infoGROUP BY student_idORDER BY create_time DESCLIMIT 100; 各自单列索引的情况下，耗时大约1.5s（上面不加索引的情况下耗时1s） ​ 8.0中 &#x3D;&#x3D;todo 不明原因，未得到解决，上述方式在5.7中大约需要1.5s左右，而在8.0中需要几分钟的时间。&#x3D;&#x3D; 联合索引的情况① ： 先删除除主键外其他的单列索引 idx_sid_cre_time(student_id,create_time)，student_id在前 ​ 5.7： 123456789101112ALTER TABLE student_infoADD INDEX idx_sid_cre_time(student_id,create_time);SHOW INDEX FROM student_info;EXPLAIN SELECT student_id,COUNT(*) AS num FROM student_infoGROUP BY student_idORDER BY create_time DESCLIMIT 100; 耗时约&#x3D;&#x3D;300ms&#x3D;&#x3D;左右（未加索引1s左右，单列索引1.5s左右） 8.0： 12345678910111213141516DROP INDEX idx_sid ON student_info ;DROP INDEX idx_cre_time ON student_info;DROP INDEX idx_sid_cre_time ON student_info;ALTER TABLE student_infoADD INDEX idx_sid_cre_time(student_id,create_time DESC);SHOW INDEX FROM student_info;EXPLAIN SELECT student_id,COUNT(*) AS num FROM student_infoGROUP BY student_idORDER BY create_time DESCLIMIT 100; 索引不加DESC时，耗时约&#x3D;&#x3D;800ms&#x3D;&#x3D;左右（不加索引1s左右，单列索引几分钟） 索引加DESC时，耗时约&#x3D;&#x3D;300ms&#x3D;&#x3D;左右（不加索引1s左右，单列索引几分钟） 联合索引的情况② ： idx_cre_sid_time(create_time,student_id)，create_time在前 在语句执行中，先进行group by 所以此时如果存在idx_sid(student_id)的话，会优先使用group by student_id的student_id索引（idx_sid），这样就变成了使用单列索引，联合索引idx_sid_cre_time就不起作用了。 如果不存在idx_sid，只有联合索引idx_cre_sid_time： ​ 5.7： 123456789101112DROP INDEX idx_sid ON student_info ;DROP INDEX idx_cre_time ON student_info;DROP INDEX idx_sid_cre_time ON student_info;ALTER TABLE student_infoADD INDEX idx_cre_sid_time(create_time,student_id);SELECT student_id,COUNT(*) AS num FROM student_infoGROUP BY student_idORDER BY create_time DESCLIMIT 100; 耗时约&#x3D;&#x3D;800ms左右&#x3D;&#x3D; （未加索引1s左右，单列索引1.5s左右，idx_sid_cre_time索引耗时约300ms） ​ 8.0 ： 12345678910111213DROP INDEX idx_sid ON student_info ;DROP INDEX idx_cre_time ON student_info;DROP INDEX idx_sid_cre_time ON student_info;DROP INDEX idx_cre_sid_time ON student_info;ALTER TABLE student_infoADD INDEX idx_cre_sid_time(create_time DESC,student_id);SELECT student_id,COUNT(*) AS num FROM student_infoGROUP BY student_idORDER BY create_time DESCLIMIT 100; 索引不加DESC时，耗时约&#x3D;&#x3D;1s&#x3D;&#x3D;左右（不加索引1s左右，单列索引几分钟，idx_sid_cre_time索引800ms左右） 索引加DESC时，耗时约&#x3D;&#x3D;1s&#x3D;&#x3D;左右（不加索引1s左右，单列索引几分钟，idx_sid_cre_time索引300ms左右） 4). UPDATE、DELETE 的 WHERE 条件列对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。 原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。 5). DISTINCT 字段需要创建索引有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。 比如，我们想要查询课程表中不同的 student_id 都有哪些，如果我们没有对 student_id 创建索引，执行 SQL 语句： 1SELECT DISTINCT(student_id) FROM `student_info`; 运行结果（600637 条记录，运行时间 0.683s ）： 如果我们对 student_id 创建索引，再执行 SQL 语句： 1SELECT DISTINCT(student_id) FROM `student_info`; 运行结果（600637 条记录，运行时间 0.010s ）： SQL 查询效率有了提升，同时显示出来的 student_id 还是按照 递增的顺序 进行展示的。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。 6). 多表 JOIN 连接操作时，创建索引注意事项首先， &#x3D;&#x3D;连接表的数量尽量不要超过 3 张&#x3D;&#x3D;，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。 其次， 对 WHERE 条件创建索引 ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。 最后，&#x3D;&#x3D;类似字符串和int比较时，会存在隐式转换，即使用了函数，一旦使用了函数就会让索引失效。 对用于连接的字段创建索引 ，并且该字段在多张表中的 类型必须一致 。&#x3D;&#x3D;比如 course_id 在 student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。 举个例子，如果我们只对 student_id 创建索引，执行 SQL 语句： 1234SELECT course_id, name, student_info.student_id, course_name FROM student_info JOIN course ON student_info.course_id = course.course_id WHERE name = &#x27;462eed7ac6e791292a79&#x27;; 运行结果（1 条数据，运行时间 0.189s ）： 这里我们对 name 创建索引，再执行上面的 SQL 语句，运行时间为 0.002s 。 7). 使用列的类型小的创建索引 8). 使用字符串前缀创建索引 创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引 123create table shop(address varchar(120) not null); alter table shop add index(address(12)); 问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字 段的散列度(选择性)会降低。怎么计算不同的长度的选择性呢？ 先看一下字段在全部数据中的选择度： 1select count(distinct address) / count(*) from shop; 通过不同长度去计算，与全表的选择性对比： 公式： 1count(distinct left(列名, 索引长度))/count(*) 例如： 12345select count(distinct left(address,10)) / count(*) as sub10, -- 截取前10个字符的选择度 count(distinct left(address,15)) / count(*) as sub11, -- 截取前15个字符的选择度 count(distinct left(address,20)) / count(*) as sub12, -- 截取前20个字符的选择度 count(distinct left(address,25)) / count(*) as sub13 -- 截取前25个字符的选择度from shop; 引申另一个问题：索引列前缀对排序的影响 拓展：Alibaba《Java开发手册》 &#x3D;&#x3D;在 varchar 字段上建立索引时，必须指定索引长度，根据实际文本区分度决定索引长度。&#x3D;&#x3D; 说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会 高达 90% 以上 ，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。 9). 区分度高(散列性高)的列适合作为索引 10). 使用最频繁的列放到联合索引的左侧11). 在多个字段都要创建索引的情况下，联合索引优于单值索引3. 限制索引的数目 4. 哪些情况不适合创建索引 WHERE条件（包括GROUP BY、ORDER BY)里用不到的字段不需要创建索引 数据量小的表最好不要使用索引 有大量重复数据的列上不要建立索引 比如性别。 避免对经常更新的表创建过多的索引 不建议用无序的值作为索引 例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。 删除不再使用或者很少使用的索引 不要定义冗余或重复的索引 小记 我们进行内联查询前，最好能限制连的表大小的条件都先用上了，同时尽量让条件查询和分组执行的表尽量小&#x3D;&#x3D;&#x3D;&#x3D;》CSDN博客_mysql联表查询优化①","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://example.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://example.com/tags/MySQL/"}]},{"title":"JVM上篇","slug":"JVM上篇","date":"2022-03-19T05:20:02.937Z","updated":"2022-03-19T06:58:22.647Z","comments":true,"path":"2022/03/19/JVM上篇/","link":"","permalink":"https://example.com/2022/03/19/JVM%E4%B8%8A%E7%AF%87/","excerpt":"","text":"JVM上篇JVM与Java体系结构1. Java虚拟机整体架构祥图 2.Java代码执行过程详图 3. JVM的架构模型","categories":[{"name":"JVM","slug":"JVM","permalink":"https://example.com/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://example.com/tags/JVM/"}]},{"title":"Filter/ Lstener/ Servlet/四大域对象","slug":"Filter、Listener、Servlet、四大域对象","date":"2022-03-19T05:20:02.934Z","updated":"2022-03-19T06:59:02.720Z","comments":true,"path":"2022/03/19/Filter、Listener、Servlet、四大域对象/","link":"","permalink":"https://example.com/2022/03/19/Filter%E3%80%81Listener%E3%80%81Servlet%E3%80%81%E5%9B%9B%E5%A4%A7%E5%9F%9F%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"FilterFilter-CSDN博客_java过滤器 LstenerFilter与Listener - 简书 (jianshu.com) Listener(监听器)的简单介绍_LrvingTc的博客-CSDN博客_listener ServletJavaWeb——Servlet（全网最详细教程包括Servlet源码分析）_扬俊的小屋-CSDN博客_servlet 四大域对象JavaWeb四大域对象 - 简书 (jianshu.com) JAVA中的四大域对象总结_kun blog-CSDN博客_域对象","categories":[{"name":"java","slug":"java","permalink":"https://example.com/categories/java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://example.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"一级域名","slug":"一级域名","date":"2022-03-19T05:20:02.928Z","updated":"2022-03-19T06:00:25.423Z","comments":true,"path":"2022/03/19/一级域名/","link":"","permalink":"https://example.com/2022/03/19/%E4%B8%80%E7%BA%A7%E5%9F%9F%E5%90%8D/","excerpt":"","text":"一级域名1. 购买域名 地址：域名_域名查询_域名注册_.com_.cn-阿里云 (aliyun.com) 任何服务，都可以不买，只购买域名使用权 选择个人 选择个人信息 未实名认证的，进行阿里云个人实名认证 (aliyun.com) 选择已阅读，购买 2. 等待审核进入控制台，点击域名列表可以看到，域名正在审核","categories":[{"name":"服务器","slug":"服务器","permalink":"https://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"域名","slug":"域名","permalink":"https://example.com/tags/%E5%9F%9F%E5%90%8D/"}]},{"title":"typora","slug":"使用typora写文档传图片，再上传石墨等网站的方法","date":"2022-03-19T05:20:02.925Z","updated":"2022-03-19T06:00:16.520Z","comments":true,"path":"2022/03/19/使用typora写文档传图片，再上传石墨等网站的方法/","link":"","permalink":"https://example.com/2022/03/19/%E4%BD%BF%E7%94%A8typora%E5%86%99%E6%96%87%E6%A1%A3%E4%BC%A0%E5%9B%BE%E7%89%87%EF%BC%8C%E5%86%8D%E4%B8%8A%E4%BC%A0%E7%9F%B3%E5%A2%A8%E7%AD%89%E7%BD%91%E7%AB%99%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"使用typora写文档传图片，再上传石墨等网站的好方法1. typora下载typora开始收费，我们可以使用不收费的老版本 下载链接 2. typora图床picgotypora不像word，word可以直接将上传的图片保存在文件当中，而typora不行。但是typora支持picgo插件的使用，所以，我们下在picgo 下载链接 3. 七牛云和picgo的使用，二级域名（如果不想弄直接第4步骤）注册七牛云 ，并开通对象存储 picgo使用七牛云图床 - 知乎 。为七牛云配置二级域名（前提是有了一级域名）：二级域名-石墨 4. picgo 配置：进入picgo，点击左侧的图床设置，选择七牛图床。按下图所示填写配置，SecretKey向 j j 索取。 SbOIcbA56xQGcpZyyLDtuARvi3COHhlBxa-IZxDi ytte-picgo https://blogimg.ytte.top/ z2 img-sunsifan&#x2F;或者是img-wuhao 伍昊： 孙思凡： 将最后 一项，指定存储路径更改为：img-sunsifan。 5. typora设置 打开typora后， 点击左上角文件， 点击偏好设置， 点击图像， 如图进行配置， 成功就会出现如图信息， &#x3D;&#x3D;大功告成&#x3D;&#x3D; 6. picgo的使用使用截图软件截图，打开picgo点记左侧的上传区，点击剪切板图片上传，上传成功后自动将图片地址返回到剪切板当中。 注意：如果直接截图后直接粘贴到typora文中，使用的是标签，在有的编辑器不能正常识别（比如石墨），所以最好先按上面方法。","categories":[{"name":"杂项","slug":"杂项","permalink":"https://example.com/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"typora","slug":"typora","permalink":"https://example.com/tags/typora/"}]},{"title":"谷粒商城步骤笔记","slug":"谷粒商城步骤笔记","date":"2022-03-19T05:20:02.922Z","updated":"2022-03-19T05:54:28.627Z","comments":true,"path":"2022/03/19/谷粒商城步骤笔记/","link":"","permalink":"https://example.com/2022/03/19/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E6%AD%A5%E9%AA%A4%E7%AC%94%E8%AE%B0/","excerpt":"","text":"谷粒商城步骤笔记使用人人代码生成器视频&#x3D;&#x3D;&#x3D;&#x3D;》谷粒商城——p17 clone人人代码生成器 放进项目中加入模块 在application.yml修改数据库相关信息 在generator.properties中修改参数 12345678910mainPath=com.atguigu#包名package=com.atguigu.gulimallmoduleName=product#作者author=yttejx#Emailemail=1026190684@qq.com#表前缀(类名不会包含表前缀)tablePrefix=pms_ 更改renren-generator的resources的template的Controller模板中@RequiresPermissions注解和导包注释掉，以后再导入使用。 启动renren-generator的Application。网页访问localhost:80，点击显示全部表格，全选表格，点击生成代码。 将生成的代码中main包复制粘贴到product项目下。 新建模块（maven）取名，gulimall_common（项目的公共资源全部放在这里） 查看product项目中报错信息。将相应的pom 和类（renren自己创建的工具类）加入到common项目中 从renren-faster中导入 包： exception utils Constant PageUtils Query R validator xss 去掉XssFilter和XssHttpServletRequestWrapper，是防跨站脚本攻击的，以后用springsecurity来实现。 这里需要导包Servlet，同时设置scope 为provided，因为tomcat内有Servlet pom： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;mybatis.plus.boot.starter.version&gt;3.5.1&lt;/mybatis.plus.boot.starter.version&gt; &lt;lombok.version&gt;1.18.22&lt;/lombok.version&gt; &lt;commons.lang.version&gt;2.6&lt;/commons.lang.version&gt; &lt;httpcore.version&gt;4.4.15&lt;/httpcore.version&gt; &lt;shiro.version&gt;1.4.0&lt;/shiro.version&gt; &lt;commons.io.version&gt;2.5&lt;/commons.io.version&gt; &lt;mysql.connector.version&gt;8.0.28&lt;/mysql.connector.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.plus.boot.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;version&gt;$&#123;commons.lang.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpcore --&gt; &lt;!--java 发送http请求--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpcore&lt;/artifactId&gt; &lt;version&gt;$&#123;httpcore.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;$&#123;commons.io.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;$&#123;shiro.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;shiro.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.connector.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;!-- tomcat内有Servlet--&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.validation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.validation-api&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; product的UndoLogEntity的rollbackInfo属性，数据库中使用的是Longblob，实体类中使用byte[]。 配置&amp;测试服务的crud功能视频&#x3D;&#x3D;&#x3D;&#x3D;》谷粒商城——p18 每个项目都需要crud，所以在common中导入mysql驱动 配置数据源 123456spring: datasource: username: root password: as123 url: jdbc:mysql://localhost:3380/gulimall_pms?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai driver-class-name: com.mysql.cj.jdbc.Driver 配置mybatis-plus 使用MapperScan 1@MapperScan(&quot;com.atguigu.gulimall.product.dao&quot;) 告诉mybatis-plus，sql映射文件位置 使用自增主键（以后数据量大了在使用其他主键策略） 12345mybatis-plus: mapper-locations: classpath*:/mapper/**/*.xml global-config: db-config: id-type: auto crud测试 1234567891011121314151617@Test void contextLoads() &#123; BrandEntity brandEntity = new BrandEntity(); brandEntity.setName(&quot;华为&quot;); brandService.save(brandEntity); System.out.println(&quot;保存成功----------&quot;); brandEntity.setBrandId(1L); brandEntity.setDescript(&quot;华为手机&quot;); brandService.updateById(brandEntity); System.out.println(&quot;更新成功---------&quot;); List&lt;BrandEntity&gt; list = brandService.list(new LambdaQueryWrapper&lt;BrandEntity&gt;().eq(BrandEntity::getBrandId, &quot;1&quot;)); list.forEach(System.out::println); System.out.println(&quot;查询成功---------&quot;); &#125; 逆向工程生成所有代码 视频&#x3D;&#x3D;&#x3D;&#x3D;》p19 分","categories":[{"name":"项目","slug":"项目","permalink":"https://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"谷粒商城","slug":"谷粒商城","permalink":"https://example.com/tags/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/"}]},{"title":"二级域名","slug":"二级域名","date":"2022-03-19T05:20:02.916Z","updated":"2022-03-19T05:59:16.500Z","comments":true,"path":"2022/03/19/二级域名/","link":"","permalink":"https://example.com/2022/03/19/%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D/","excerpt":"","text":"二级域名给七牛云配置阿里云所属顶级域名的二级域名 1. 首先要有一级域名一级域名-石墨 2.配置七牛云尽量选择华南地区（便宜）。 点击域名 点击域名绑定 点击创建 如下图，说明创建成功， 点击复制CNAME（七牛云页面不要关闭） 进入阿里云控制台 点击域名&#x3D;&gt;点击域名列表 点击解析 点击添加记录 &#x3D;&gt;点击确认 这里的主机记录和记录值前缀要一致 如果状态显示正常，即可 再回到七牛云中，观察是否设置成功","categories":[{"name":"服务器","slug":"服务器","permalink":"https://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"域名","slug":"域名","permalink":"https://example.com/tags/%E5%9F%9F%E5%90%8D/"}]},{"title":"session，cookie，token","slug":"session，cookie，token","date":"2022-03-14T10:19:04.000Z","updated":"2022-03-19T05:16:32.982Z","comments":true,"path":"2022/03/14/session，cookie，token/","link":"","permalink":"https://example.com/2022/03/14/session%EF%BC%8Ccookie%EF%BC%8Ctoken/","excerpt":"","text":"彻底弄懂session，cookie，token - SegmentFault 思否 彻底理解cookie，session，token - 墨颜丶 - 博客园 (cnblogs.com)","categories":[{"name":"java","slug":"java","permalink":"https://example.com/categories/java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://example.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Consumer、Supplier、Predicate和Function","slug":"Consumer、Supplier、Predicate和Function","date":"2022-03-14T01:35:19.000Z","updated":"2022-03-19T07:04:55.270Z","comments":true,"path":"2022/03/14/Consumer、Supplier、Predicate和Function/","link":"","permalink":"https://example.com/2022/03/14/Consumer%E3%80%81Supplier%E3%80%81Predicate%E5%92%8CFunction/","excerpt":"","text":"Java8之Consumer、Supplier、Predicate和Function攻略 - 公众号好好学java - 博客园 (cnblogs.com)","categories":[{"name":"java","slug":"java","permalink":"https://example.com/categories/java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://example.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"ZooKeeper","slug":"ZooKeeper","date":"2022-03-14T01:35:19.000Z","updated":"2022-03-19T06:02:09.261Z","comments":true,"path":"2022/03/14/ZooKeeper/","link":"","permalink":"https://example.com/2022/03/14/ZooKeeper/","excerpt":"","text":"ZooKeeper非docker 单机（本地）安装配置启动视频&#x3D;&#x3D;&#x3D;&#x3D;》_哔哩哔哩_bilibili p7 需要jdk环境，并配置环境变量 linux安装jdk8 下载ZooKeeper压缩包（Apache Downloads)放在linux下的&#x2F;mnt&#x2F;zookeeper下。 tar -zxvf apache-zookeeper-3.5.7-bin.tar.gz 123454. 将文件夹改名 ```shell mv apache-zookeeper-3.5.7-bin/ zookeeper-3.5.7/ 更改conf下 的zoo-sample.cfg为zoo.cfg 更改zoo.cfg中 12dataDir=/mnt/zookeeper/zookeeper-3.5.7/datadataLogDir=/mnt/zookeeper/zookeeper-3.5.7/dataLog 启动服务端： 注意：需要在&#x2F;mnt&#x2F;zookeeper&#x2F;zookeeper-3.5.7&#x2F;目录下使用启动命令bin/zkServer.sh start 不能再&#x2F;mnt&#x2F;zookeeper&#x2F;zookeeper-3.5.7&#x2F;bin&#x2F;目录下使用zkServer.sh start 使用jps -l 查看是否启动了zookeeper 的java进程。 启动客户端： bin/zkCli.sh ls /查看节点 quit退出客户端 bin/zkServer.sh status查看zookeeper的状态（standalone单机模式） bin/zkServer.sh stop 停止服务器端 docker配置参数解读视频&#x3D;&#x3D;&#x3D;&#x3D;》p8 tickTime&#x3D;2000——通信的心跳时间 ZooKeeper服务器与客户端之间通信频率，每2000ms发送一次。 initLimit&#x3D;10——LF初始通信时限 Leader与Follower初始连接是 3.","categories":[{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"https://example.com/categories/ZooKeeper/"}],"tags":[{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"https://example.com/tags/ZooKeeper/"}]}],"categories":[{"name":"服务器","slug":"服务器","permalink":"https://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"java","slug":"java","permalink":"https://example.com/categories/java/"},{"name":"MySQL","slug":"MySQL","permalink":"https://example.com/categories/MySQL/"},{"name":"JVM","slug":"JVM","permalink":"https://example.com/categories/JVM/"},{"name":"杂项","slug":"杂项","permalink":"https://example.com/categories/%E6%9D%82%E9%A1%B9/"},{"name":"项目","slug":"项目","permalink":"https://example.com/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"https://example.com/categories/ZooKeeper/"}],"tags":[{"name":"Https","slug":"Https","permalink":"https://example.com/tags/Https/"},{"name":"Thread","slug":"Thread","permalink":"https://example.com/tags/Thread/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://example.com/tags/SpringCloud/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://example.com/tags/SpringBoot/"},{"name":"MySQL","slug":"MySQL","permalink":"https://example.com/tags/MySQL/"},{"name":"JVM","slug":"JVM","permalink":"https://example.com/tags/JVM/"},{"name":"基础","slug":"基础","permalink":"https://example.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"域名","slug":"域名","permalink":"https://example.com/tags/%E5%9F%9F%E5%90%8D/"},{"name":"typora","slug":"typora","permalink":"https://example.com/tags/typora/"},{"name":"谷粒商城","slug":"谷粒商城","permalink":"https://example.com/tags/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/"},{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"https://example.com/tags/ZooKeeper/"}]}